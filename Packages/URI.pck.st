'From Cuis7.3 [latest update: #6971] on 8 January 2025 at 2:40:18 pm'!
'Description '!
!provides: 'URI' 1 3!
SystemOrganization addCategory: #URI!
SystemOrganization addCategory: #'URI-Public'!
SystemOrganization addCategory: #'URI-Tests'!


!classDefinition: #MultiDictionary category: #'URI-Public'!
OrderedCollection subclass: #MultiDictionary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'MultiDictionary class' category: #'URI-Public'!
MultiDictionary class
	instanceVariableNames: ''!

!classDefinition: #QueryDictionary category: #'URI-Public'!
MultiDictionary subclass: #QueryDictionary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'QueryDictionary class' category: #'URI-Public'!
QueryDictionary class
	instanceVariableNames: ''!

!classDefinition: #ParseError category: #'URI-Public'!
Error subclass: #ParseError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'ParseError class' category: #'URI-Public'!
ParseError class
	instanceVariableNames: ''!

!classDefinition: #URIParseError category: #'URI-Public'!
Error subclass: #URIParseError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'URIParseError class' category: #'URI-Public'!
URIParseError class
	instanceVariableNames: ''!

!classDefinition: #TestPercentEncoding category: #'URI-Tests'!
TestCase subclass: #TestPercentEncoding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Tests'!
!classDefinition: 'TestPercentEncoding class' category: #'URI-Tests'!
TestPercentEncoding class
	instanceVariableNames: ''!

!classDefinition: #TestURI category: #'URI-Tests'!
TestCase subclass: #TestURI
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Tests'!
!classDefinition: 'TestURI class' category: #'URI-Tests'!
TestURI class
	instanceVariableNames: ''!

!classDefinition: #TestURIPath category: #'URI-Tests'!
TestCase subclass: #TestURIPath
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Tests'!
!classDefinition: 'TestURIPath class' category: #'URI-Tests'!
TestURIPath class
	instanceVariableNames: ''!

!classDefinition: #RecursiveDescentParser category: #'URI-Public'!
Object subclass: #RecursiveDescentParser
	instanceVariableNames: 'input lookahead shift'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'RecursiveDescentParser class' category: #'URI-Public'!
RecursiveDescentParser class
	instanceVariableNames: ''!

!classDefinition: #PercentEncoding category: #'URI-Public'!
RecursiveDescentParser subclass: #PercentEncoding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'PercentEncoding class' category: #'URI-Public'!
PercentEncoding class
	instanceVariableNames: ''!

!classDefinition: #URIParser category: #'URI-Public'!
RecursiveDescentParser subclass: #URIParser
	instanceVariableNames: 'uri'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'URIParser class' category: #'URI-Public'!
URIParser class
	instanceVariableNames: ''!

!classDefinition: #URI category: #'URI-Public'!
Object subclass: #URI
	instanceVariableNames: 'scheme authority path query fragment'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'URI class' category: #'URI-Public'!
URI class
	instanceVariableNames: ''!

!classDefinition: #URIAuthority category: #'URI-Public'!
Object subclass: #URIAuthority
	instanceVariableNames: 'userinfo host port'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'URIAuthority class' category: #'URI-Public'!
URIAuthority class
	instanceVariableNames: ''!

!classDefinition: #URIPath category: #'URI-Public'!
Object subclass: #URIPath
	instanceVariableNames: 'segments isAbsolute'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'URIPath class' category: #'URI-Public'!
URIPath class
	instanceVariableNames: ''!


!MultiDictionary commentStamp: '<historical>' prior: 0!
Part Dictionary, part Bag, slower than both (well, either).

I am a dictionary that allows multiple values for a key.  I am meant to be used for tasks such as interpreting a query string or the contents of an application/x-www-form-urlencoded post, or storing MIME headers.  I support case-insensitive lookups when using String keys.

To support my tasks, I also track order of key insertion.
!

!ParseError commentStamp: 'ess 11/19/2024 09:53:48' prior: 0!
I am a class for errors generated by BaseParser.!

!RecursiveDescentParser commentStamp: 'ess 11/19/2024 10:23:00' prior: 0!
I am a utility for writing recursive-descent parsers.

I have a single-token lookahead, but I also support backtracking.  I differ from Parser in not being specific to Smalltalk.

I am little more than a thin wrapper around a PositionableStream, i.e., my #lookahead equates to a stream's #peek and my #consume equates to a stream's #next.

My main differenece from a stream is my #step method, which supports mapping one or more items from the underlying collection as a single token.  For many uses, this allows you to write parsers without having separate tokenization and parsing stages.  (This is sometimes convenient, and sometimes necessary.)  To do the same using only a stream can require distracting bookkeeping of the stream's underlying position.

To avoid that bookkeeping, I provide the methods #save and #restore to save and restore, respectively, the stream's position.  Saved positions can be nested.  To implement backtracking or multi-token lookahead, use #withSaveDo: to manage all this.

I also provide a number of convenience methods that map directly to tests of the #lookahead token, but check for end-of-input, i.e., #isDigit is equivalent to `lookahead notNil and: [ lookahead isDigit ]`.!

!PercentEncoding commentStamp: '<historical>' prior: 0!
Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-2.1!

!URIAuthority commentStamp: '<historical>' prior: 0!
Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-3.2!

!URIPath commentStamp: '<historical>' prior: 0!
I am the path component of an RFC3986 URI.!

!MultiDictionary methodsFor: 'accessing' stamp: 'ess 1/8/2025 14:23:57'!
allAt: aKey

	| result |
	result := OrderedCollection new.
	self associationsDo: [:each | each key = aKey ifTrue: [result add: each value]].
	^result! !

!MultiDictionary methodsFor: 'accessing' stamp: 'ess 1/8/2025 14:24:22'!
allAt: aKey ifAbsent: exceptionBlock

	| result |
	result := self allAt: aKey.
	result isEmpty ifTrue: [^exceptionBlock value].
	^result! !

!MultiDictionary methodsFor: 'accessing' stamp: 'ess 1/8/2025 11:38:26'!
at: aKey

	^self
		at: aKey
		ifAbsent: [nil]! !

!MultiDictionary methodsFor: 'accessing' stamp: 'ess 1/8/2025 14:25:15'!
at: aKey ifAbsent: exceptionBlock

	self associationsDo: [:each | each key = aKey ifTrue: [^each value]].
	^exceptionBlock value! !

!MultiDictionary methodsFor: 'accessing' stamp: 'ess 1/8/2025 11:39:17'!
at: aKey put: aValue

	firstIndex to: lastIndex do:
		[:index | | each |
		each := array at: index.
		each key = aKey
			ifTrue:
				[array
					at: index
					put: each key -> aValue.
				^aValue]].
	^self
		at: aKey
		putNew: aValue! !

!MultiDictionary methodsFor: 'accessing' stamp: 'ess 1/8/2025 11:39:24'!
at: aKey putNew: aValue

	super addLast: aKey -> aValue.
	^aValue! !

!MultiDictionary methodsFor: 'enumerating' stamp: 'ess 11/3/2024 13:26:44'!
associationsDo: aBlock
	"Evaluate aBlock for each of the receiver's key/value associations."

	super do: aBlock! !

!MultiDictionary methodsFor: 'enumerating' stamp: 'ess 1/8/2025 14:28:21'!
collect: aBlock 
	"Evaluate aBlock with each of my values as the argument.  Collect the resulting values into a collection that is like me. Answer with the new collection."
	
	| result |
	result := self species new.
	self associationsDo:
		[:each |
		result
			at: each key
			putNew: (aBlock value: each value)].
	^result! !

!MultiDictionary methodsFor: 'enumerating' stamp: 'ess 1/8/2025 14:27:16'!
do: aBlock

	self valuesDo: aBlock! !

!MultiDictionary methodsFor: 'enumerating' stamp: 'ess 1/8/2025 11:40:02'!
keysAndValuesDo: aBlock

	^self associationsDo:
		[:each |
		aBlock
			value: each key
			value: each value]! !

!MultiDictionary methodsFor: 'enumerating' stamp: 'ess 1/8/2025 11:40:08'!
keysDo: aBlock 
	"Evaluate aBlock for each of the receiver's keys."

	self associationsDo: [:each | aBlock value: each key]! !

!MultiDictionary methodsFor: 'enumerating' stamp: 'ess 1/8/2025 11:40:13'!
reverseDo: aBlock
	"Evaluate aBlock for each of the receiver's values in reverse order."

	super reverseDo: [:each | aBlock value: each value]! !

!MultiDictionary methodsFor: 'enumerating' stamp: 'ess 1/8/2025 14:29:30'!
select: aBlock 
	"Evaluate aBlock with each of my values as the argument.  Collect into a new  dictionary, only those associations for which aBlock evaluates to true."
	
	| result |
	result := self species new.
	self associationsDo:
		[:each |
		(aBlock value: each value) ifTrue:
			[result
				at: each key
				putNew: each value]].
	^result! !

!MultiDictionary methodsFor: 'enumerating' stamp: 'ess 1/8/2025 11:40:27'!
valuesDo: aBlock 
	"Evaluate aBlock for each of the receiver's keys."

	self associationsDo: [:each | aBlock value: each value]! !

!MultiDictionary class methodsFor: 'instance creation' stamp: 'ess 1/8/2025 14:02:11'!
newFrom: aCollection

	| result |
	result := self new.
	aCollection associationsDo:
		[:each | | key value |
		[key := each key.
		value := each value]
			on: Error
			do: [key := each.
				value := nil].
		result
			at: key
			putNew: value].
	^result! !

!QueryDictionary methodsFor: 'converting' stamp: 'ess 1/8/2025 14:12:05'!
asQueryString

	| separator |
	separator := ''.
	^String streamContents:
		[:stream |
		self associationsDo:
			[:each |
			stream nextPutAll: separator.
			separator := '&'.
			stream nextPutAll: each key asString percentEncoded.
			each value ifNotNil:
				[stream
					nextPut: $=;
					nextPutAll: each value asString percentEncoded]]]! !

!QueryDictionary methodsFor: 'private' stamp: 'ess 1/8/2025 11:43:32'!
setQueryString: aString

	(aString findTokens: '&') do:
		[:each | | separator key value |
		separator := each indexOf: $=.
		separator isZero
			ifTrue:
				[key := each.
				self
					at: key percentDecoded
					putNew: nil]
			ifFalse:
				[key := each
					copyFrom: 1
					to: separator - 1.
				value := each
					copyFrom: separator + 1
					to: each size.
				self
					at: key percentDecoded
					putNew: value percentDecoded]].
	^self! !

!QueryDictionary class methodsFor: 'instance creation' stamp: 'ess 1/8/2025 11:43:40'!
fromString: aString

	^self new
		setQueryString: aString! !

!TestPercentEncoding methodsFor: 'tests' stamp: 'ess 1/8/2025 13:36:48'!
testEncoding1

	| decoded encoded |
	decoded := 'öb-a~da_A.Z'.
	encoded := '%C3%B6b-a~da_A.Z'.	
	self
		assert: (PercentEncoding decode: encoded)
		equals: decoded.
	self
		assert: (PercentEncoding encode: decoded)
		equals: encoded! !

!TestPercentEncoding methodsFor: 'tests' stamp: 'ess 11/3/2024 08:50:53'!
testEncoding2

	| decoded encoded |

	decoded := 'ほんとうにながいわけのわからないどめいんめいのらべるまだながくしないとたりない.ほんとうにながいわけのわからないどめいんめいのらべるまだながくしないとたりない.ほんとうにながいわけのわからないどめいんめいのらべるまだながくしないとたりない.w3.mag.keio.ac.jp'.

	encoded := '%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%9F%E3%82%8A%E3%81%AA%E3%81%84.%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%9F%E3%82%8A%E3%81%AA%E3%81%84.%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%9F%E3%82%8A%E3%81%AA%E3%81%84.w3.mag.keio.ac.jp'.
	
	self
		assert: (PercentEncoding decode: encoded)
		equals: decoded.
	self
		assert: (PercentEncoding encode: decoded)
		equals: encoded! !

!TestPercentEncoding methodsFor: 'tests' stamp: 'ess 11/3/2024 08:53:01'!
testNormalization
	"From https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2"

	self
		assert: (PercentEncoding normalize: '%7bfoo%7d')
		equals: '%7Bfoo%7D'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:37:14'!
skipExample3
	"This test is broken because IPv6 parsing is not yet implemented."

	| uri |
	uri := URI fromString: 'ldap://[2001:db8::7]/c=GB?objectClass?one'.
	self
		assert: uri scheme
		equals: 'ldap'.
	self
		assert: uri host
		equals: '[2001:db8::7]'.
	self
		assert: uri path asString
		equals: 'c=GB'.
	self
		assert: uri query
		equals: 'objectClass?one'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:53:55'!
testConstruction

	| uri |
	uri := URI new
		scheme: #https;
		userinfo: 'john:1234';
		host: 'www.domain.com';
		port: 8080;
		path: '/folder/file';
		query: {'id' -> 42. 'name' -> 'john.doe'};
		fragment: 'row=1';
		yourself.
	self
		assert: uri asString
		equals: 'https://john:1234@www.domain.com:8080/folder/file?id=42&name=john.doe#row=1'
! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:37:20'!
testExample2
	"Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-1.1.2"

	| uri |
	uri := URI fromString: 'http://www.ietf.org/rfc/rfc2396.txt'.
	self
		assert: uri scheme
		equals: 'http'.
	self
		assert: uri host
		equals: 'www.ietf.org'.
	self
		assert: uri path asString
		equals: '/rfc/rfc2396.txt'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:37:26'!
testExample4

	| uri |
	uri := URI fromString: 'mailto:John.Doe@example.com'.
	self
		assert: uri scheme
		equals: 'mailto'.
	self
		assert: uri path segments first
		equals: 'John.Doe@example.com'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:37:31'!
testExample5

	| uri |
	uri := URI fromString: 'news:comp.infosystems.www.servers.unix'.
	self
		assert: uri path segments first
		equals: 'comp.infosystems.www.servers.unix'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:37:36'!
testExample6

	| uri |
	uri := URI fromString: 'tel:+1-816-555-1212'.
	self
		assert: uri path asString
		equals: '+1-816-555-1212'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:37:40'!
testExample7

	| uri |
	uri := URI fromString: 'telnet://192.0.2.16:80'.
	self
		assert: uri scheme
		equals: 'telnet'.
	self
		assert: uri host
		equals: #(192 0 2 16).
	self
		assert: uri port
		equals: 80! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:37:45'!
testExample8

	| uri |
	uri := URI fromString: 'urn:oasis:names:specification:docbook:dtd:xml:4.1.2'.
	self
		assert: uri scheme
		equals: 'urn'.
	self
		assert: uri path asString
		equals: 'oasis:names:specification:docbook:dtd:xml:4.1.2'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:37:50'!
testExample9

	| uri |
	uri := URI fromString: 'foo://example.com:8042/over/there?name=ferret#nose'.
	self
		assert: uri scheme
		equals: 'foo'.
	self
		assert: uri host
		equals: 'example.com'.
	self
		assert: uri port
		equals: 8042.
	self
		assert: uri path asString
		equals: '/over/there'.
	self
		assert: uri query
		equals: 'name=ferret'.
	self
		assert: uri fragment
		equals: 'nose'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:37:55'!
testFileUri1
	"From Cuis-Smalltalk-URI-Kernel"
	
	| uri |
	uri := URI fromString: 'file:///path/to/file'.
	self
		assert: uri scheme
		equals: 'file'.
	self
		assert: uri path asString
		equals: '/path/to/file'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:37:59'!
testFileUri2

	| uri |
	uri := URI fromString: 'file:/path/to/file'.
	self
		assert: uri path asString
		equals: '/path/to/file'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:38:03'!
testFileUri3

	| uri |
	uri := URI fromString: 'file://host.example.com/path/to/file'.
	self
		assert: uri scheme
		equals: 'file'.
	self
		assert: uri host
		equals: 'host.example.com'.
	self
		assert: uri path asString
		equals: '/path/to/file'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:38:07'!
testFileUri4

	| uri |
	uri := URI fromString: 'file://hostname/path/to/the%20file.txt'.
	self
		assert: uri path segments last
		equals: 'the%20file.txt'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:38:10'!
testFileUri5

	| uri |
	uri := URI fromString: 'file:///c:/path/to/the%20file.txt'.
	self
		assert: uri path asString
		equals: '/c:/path/to/the%20file.txt'.
	self
		assert: uri path segments last
		equals: 'the%20file.txt'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:38:15'!
testFranz1
	"From https://github.com/llibra/puri"

	| uri |
	uri := URI fromString: 'http://www.franz.com/a/b;x;y;z/c/foo?bar=baz&xxx#foo'.
	self
		assert: uri path asString
		equals: '/a/b;x;y;z/c/foo'.
	self
		assert: uri query
		equals: 'bar=baz&xxx'.
	self
		assert: uri fragment
		equals: 'foo'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:38:19'!
testFranz2

	| uri |
	uri := URI fromString: 'http://www.franz.com/a/b;x;y;z/c/%2ffoo?bar=baz&xxx#foo'.
	self
		assert: uri path asString
		equals: '/a/b;x;y;z/c/%2ffoo'.
	self
		assert: uri path segments last
		equals: '%2ffoo'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:38:27'!
testFromString1
	"From Cuis-Smalltalk-URI-Kernel"

	| uri |
	uri := URI fromString: 'https://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top'.
	self
		assert: uri scheme
		equals: 'https'.
	self
		assert: uri userinfo
		equals: 'john.doe'.
	self
		assert: uri host
		equals: 'www.example.com'.
	self
		assert: uri port
		equals: 123.
	self
		assert: uri authority asString
		equals: 'john.doe@www.example.com:123'.
	self
		assert: uri path asString
		equals: '/forum/questions/'.
	self
		assert: uri query
		equals: 'tag=networking&order=newest'.
	self
		assert: uri fragment
		equals: 'top'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:38:32'!
testFromString2

	| uri |
	uri := URI fromString: 'http://a/b/c/d;p?q'.
	self
		assert: uri host
		equals: 'a'.
	self assert: uri path isAbsolute.
	self
		assert: uri path asString
		equals: '/b/c/d;p'.
	self
		assert: uri query
		equals: 'q'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:38:39'!
testFromString8

	| uri |
	uri := URI fromString: '../../../g'.
	self assert: uri path isRelative.
	self
		assert: uri path asString
		equals: '../../../g'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:38:48'!
testLongUri

	| uri expectedHost uriString |
	
	expectedHost := '%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%9F%E3%82%8A%E3%81%AA%E3%81%84.%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%9F%E3%82%8A%E3%81%AA%E3%81%84.%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%9F%E3%82%8A%E3%81%AA%E3%81%84.w3.mag.keio.ac.jp'.

	uriString := 'http://%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%9F%E3%82%8A%E3%81%AA%E3%81%84.%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%9F%E3%82%8A%E3%81%AA%E3%81%84.%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%9F%E3%82%8A%E3%81%AA%E3%81%84.w3.mag.keio.ac.jp/'.
	
	uri := URI fromString: uriString.
	self
		assert: uri host
		equals: expectedHost! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 14:14:53'!
testParsing

	| uri |
	uri := URI fromString: 'https://john:1234@www.domain.com:8080/folder/file?id=42&name=john.doe#row=1'.
	self assert: uri scheme equals: #https.
	self assert: uri username equals: 'john'.
	self assert: uri password equals: '1234'.
	self assert: uri host equals: 'www.domain.com'.
	self assert: uri port equals: 8080.
	self assert: uri path asString equals: '/folder/file'.
	self assert: uri query equals: 'id=42&name=john.doe'.
	self assert: uri fragment equals: 'row=1'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:38:55'!
testPostgresUri1
	"From Cuis-Smalltalk-URI-Kernel"

	| uri |
	uri := URI fromString: 'postgresql://'.
	self
		assert: uri scheme
		equals: 'postgresql'.
	self assert: uri path isNil! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:38:58'!
testPostgresUri2

	| uri |
	uri := URI fromString: 'postgresql://localhost'.
	self
		assert: uri scheme
		equals: 'postgresql'.
	self
		assert: uri host
		equals: 'localhost'.
	self assert: uri path isNil! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:39:03'!
testPostgresUri3

	| uri |
	uri := URI fromString: 'postgresql://localhost:5433'.
	self
		assert: uri host
		equals: 'localhost'.
	self
		assert: uri port
		equals: 5433.
	self assert: uri path isNil! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:39:06'!
testPostgresUri4

	| uri |
	uri := URI fromString: 'postgresql://localhost/mydb'.
	self
		assert: uri path segments first
		equals: 'mydb'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:39:10'!
testPostgresUri5

	| uri |
	uri := URI fromString: 'postgresql://user@localhost'.
	self
		assert: uri userinfo
		equals: 'user'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:39:15'!
testPostgresUri6

	| uri |
	uri := URI fromString: 'postgresql://user:secret@localhost'.
	self
		assert: uri userinfo
		equals: 'user:secret'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 13:39:19'!
testPostgresUri7

	| uri |
	uri := URI fromString: 'postgresql://other@localhost/otherdb?connect_timeout=10&application_name=myapp'.
	self
		assert: uri userinfo
		equals: 'other'.
	self
		assert: uri path segments first
		equals: 'otherdb'.
	self
		assert: uri query
		equals: 'connect_timeout=10&application_name=myapp'! !

!TestURI methodsFor: 'tests' stamp: 'ess 1/8/2025 14:30:07'!
testQuery

	| uri query |
	uri := URI fromString: 'https://john:1234@www.domain.com:8080/folder/file?id=42&name=john.doe#row=1'.
	query := uri queryDictionary.
	self assert: (query at: 'id') equals: '42'.
	self assert: (query at: 'name') equals: 'john.doe'! !

!TestURIPath methodsFor: 'tests' stamp: 'ess 1/8/2025 13:40:55'!
testAbormalExamples
	"Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-5.4.2"
	
	| baseUri |
	baseUri := URI fromString: 'http://a/b/c/d;p?q'.
	{	'../../../g' -> 'http://a/g'.
		'../../../../g' -> 'http://a/g'.
		'/./g' -> 'http://a/g'.
		'/../g' -> 'http://a/g'.
		'g.' -> 'http://a/b/c/g.'.
		'.g' -> 'http://a/b/c/.g'.
		'g..' -> 'http://a/b/c/g..'.
		'..g' -> 'http://a/b/c/..g'.
		'./../g' -> 'http://a/b/g'.
		'./g/.' -> 'http://a/b/c/g/'.
		'g/./h' -> 'http://a/b/c/g/h'.
		'g/../h' -> 'http://a/b/c/h'.
		'g;x=1/./y' -> 'http://a/b/c/g;x=1/y'.
		'g;x=1/../y' -> 'http://a/b/c/y'.
		'g?y/./x' -> 'http://a/b/c/g?y/./x'.
		'g?y/../x' -> 'http://a/b/c/g?y/../x'.
		'g#s/./x' -> 'http://a/b/c/g#s/./x'.
		'g#s/../x' -> 'http://a/b/c/g#s/../x'.
		'http:g' -> 'http:g'
	} do:
		[:each | | relativeUri targetUri |
		relativeUri := URI fromString: each key.
		targetUri := relativeUri relativeTo: baseUri.
		self
			assert: targetUri asString
			equals: each value]! !

!TestURIPath methodsFor: 'tests' stamp: 'ess 1/8/2025 13:41:50'!
testNormalExamples
	"Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-5.4.1"
	
	| baseUri |
	baseUri := URI fromString: 'http://a/b/c/d;p?q'.
	{	'g:h' -> 'g:h'.
		'g' -> 'http://a/b/c/g'.
		'./g' -> 'http://a/b/c/g'.
		'g/' -> 'http://a/b/c/g/'.
		'/g' -> 'http://a/g'.
		'//g' -> 'http://g'.
		'?y' -> 'http://a/b/c/d;p?y'.
		'g?y' -> 'http://a/b/c/g?y'.
		'#s' -> 'http://a/b/c/d;p?q#s'.
		'g#s' -> 'http://a/b/c/g#s'.
		'g?y#s' -> 'http://a/b/c/g?y#s'.
		';x' -> 'http://a/b/c/;x'.
		'g;x' -> 'http://a/b/c/g;x'.
		'g;x?y#s' -> 'http://a/b/c/g;x?y#s'.
		'' -> 'http://a/b/c/d;p?q'.
		'.' -> 'http://a/b/c/'.
		'./' -> 'http://a/b/c/'.
		'..' -> 'http://a/b/'.
		'../' -> 'http://a/b/'.
		'../g' -> 'http://a/b/g'.
		'../..' -> 'http://a/'.
		'../../' -> 'http://a/'. 
		'../../g' -> 'http://a/g'
	} do:
		[:each | | relativeUri targetUri |
		relativeUri := URI fromString: each key.
		targetUri := relativeUri relativeTo: baseUri.
		self
			assert: targetUri asString
			equals: each value]! !

!TestURIPath methodsFor: 'tests' stamp: 'ess 1/8/2025 13:41:57'!
testWithoutDotSegments1

	| originalPath reducedPath |
	originalPath := URIPath absolute: #('a' 'b' 'c' '.' '..' '..' 'g').
	reducedPath := originalPath withoutDotSegments.	
	self
		assert: reducedPath asString
		equals: '/a/g'! !

!TestURIPath methodsFor: 'tests' stamp: 'ess 1/8/2025 13:42:05'!
testWithoutDotSegments2

	| originalPath reducedPath |
	originalPath := URIPath relative: #('mid' 'content=5' '..' '6').
	reducedPath := originalPath withoutDotSegments.	
	self
		assert: reducedPath asString
		equals: 'mid/6'! !

!RecursiveDescentParser methodsFor: 'accessing' stamp: 'ess 11/3/2024 08:41:05'!
input: aStringOrStream

	input := aStringOrStream readStream.
	self step! !

!RecursiveDescentParser methodsFor: 'backtracking' stamp: 'ess 11/19/2024 10:17:08'!
restore

	| saved |
	saved := self unsave.
	input position: saved key.
	lookahead := saved value! !

!RecursiveDescentParser methodsFor: 'backtracking' stamp: 'ess 11/27/2024 10:53:02'!
save

	shift addLast: input position -> lookahead.
	^input position! !

!RecursiveDescentParser methodsFor: 'backtracking' stamp: 'ess 1/8/2025 11:16:05'!
unsave

	shift isEmpty ifTrue: [^self error: 'RecursiveDescentParser internal error: restore without save'].
	^shift removeLast! !

!RecursiveDescentParser methodsFor: 'backtracking' stamp: 'ess 11/27/2024 10:54:42'!
withSaveDo: aUnaryBlock

	| didRestore restore |
	didRestore := false.
	restore :=
		[self restore.
		didRestore := true].
	self save.
	^[aUnaryBlock value: restore] ensure:
		[didRestore ifFalse: [self unsave]]! !

!RecursiveDescentParser methodsFor: 'initialization' stamp: 'ess 11/1/2024 19:26:09'!
initialize

	shift := OrderedCollection new! !

!RecursiveDescentParser methodsFor: 'initialization' stamp: 'ess 1/8/2025 11:15:39'!
parseError: aMessageString

	^ParseError signal: aMessageString! !

!RecursiveDescentParser methodsFor: 'parsing' stamp: 'ess 1/8/2025 11:14:26'!
consume
	"Update lookahead to the next character of the input, or nil.  Answer the old value of the lookahead."

	| la |
	la := lookahead ifNil: [^self parseError: 'Unexpected end of input'].
	self step.
	^la! !

!RecursiveDescentParser methodsFor: 'parsing' stamp: 'ess 11/28/2024 09:36:22'!
expect: aCharacter

	(self match: aCharacter) ifFalse:
		[^self parseError: 'Expected ', aCharacter asString]! !

!RecursiveDescentParser methodsFor: 'parsing' stamp: 'ess 1/8/2025 11:15:18'!
lookahead

	^lookahead! !

!RecursiveDescentParser methodsFor: 'parsing' stamp: 'ess 11/28/2024 09:57:26'!
match: aCharacter
	"Consume the next character only if it matches aCharacter.  Answer true if the match succeeded."

	| isMatch |
	isMatch := lookahead == aCharacter.
	isMatch ifTrue: [self consume].
	^isMatch! !

!RecursiveDescentParser methodsFor: 'parsing' stamp: 'ess 11/26/2024 15:43:36'!
next

	^input next! !

!RecursiveDescentParser methodsFor: 'parsing' stamp: 'ess 1/8/2025 11:15:31'!
parse

	^self subclassResponsibility! !

!RecursiveDescentParser methodsFor: 'parsing' stamp: 'ess 11/26/2024 07:41:44'!
parse: aStringOrStream

	self input: aStringOrStream.
	^self parse! !

!RecursiveDescentParser methodsFor: 'parsing' stamp: 'ess 11/27/2024 10:53:55'!
step
	"Move to next character of input."

	lookahead := input atEnd
		ifFalse: [self next]
		ifTrue: [nil]! !

!RecursiveDescentParser methodsFor: 'testing' stamp: 'ess 1/8/2025 11:13:04'!
atEnd

	^lookahead isNil! !

!RecursiveDescentParser methodsFor: 'testing' stamp: 'ess 1/8/2025 11:13:13'!
didSucceed
	"We succeeded if we parsed all the input."

	^self atEnd! !

!RecursiveDescentParser methodsFor: 'testing' stamp: 'ess 1/8/2025 11:13:25'!
isAscii

	^lookahead notNil
		and: [lookahead codePoint <= 127]! !

!RecursiveDescentParser methodsFor: 'testing' stamp: 'ess 1/8/2025 11:13:37'!
isDigit

	^lookahead notNil
		and: [lookahead isDigit]! !

!RecursiveDescentParser class methodsFor: 'parsing' stamp: 'ess 11/26/2024 07:41:34'!
parse: aStringOrStream

	^self new parse: aStringOrStream! !

!PercentEncoding methodsFor: 'parsing' stamp: 'ess 1/8/2025 11:17:39'!
parse

	^String streamContents:
		[:stream | | characters |
		[self atEnd] whileFalse:
			[(lookahead = $%
					and: [(characters := self readEncodedCharacters) notNil])
				ifTrue: [stream nextPutAll: characters]
				ifFalse: [stream nextPut: self consume]]]! !

!PercentEncoding methodsFor: 'private' stamp: 'ess 1/8/2025 11:19:16'!
readEncodedByte

	| a b |
	(self match: $%) ifFalse: [^nil].
	a := self readHexDigit ifNil: [^nil].
	b := self readHexDigit ifNil: [^nil].
	^(a * 16) + b! !

!PercentEncoding methodsFor: 'private' stamp: 'ess 1/8/2025 11:20:27'!
readEncodedBytes

	| bytes |
	bytes := ByteArray streamContents:
		[:stream | | byte |
		[lookahead == $%
				and: [(byte := self readEncodedByte) notNil]]
			whileTrue:
				[stream nextPut: byte]].
	^bytes notEmpty
		ifTrue: [bytes]
		ifFalse: [nil]! !

!PercentEncoding methodsFor: 'private' stamp: 'ess 1/8/2025 11:20:52'!
readEncodedCharacters

	^self withSaveDo:
		[:reset |
		[self readEncodedBytes
				ifNotNil: [:octets | CharacterSequence fromUtf8Bytes: octets]]
			on: Error
			do: [reset value.
				^nil]]! !

!PercentEncoding methodsFor: 'private' stamp: 'ess 1/8/2025 11:21:31'!
readHexDigit

	| d |
	d := lookahead ifNotNil: [self consume asUppercase digitValue].
	^(d notNil and: [d between: 0 and: 15])
		ifTrue: [d]
		ifFalse: [nil]! !

!PercentEncoding class methodsFor: 'constants' stamp: 'ess 11/2/2024 09:56:57'!
unreservedCodepoints

	^ `
		'-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~'
			inject: (Array new: 127 withAll: false)
			into:
				[ :lookup :index |
				lookup
					at:index codePoint
					put: true.
				lookup ]
	`! !

!PercentEncoding class methodsFor: 'converting' stamp: 'ess 11/3/2024 09:07:18'!
decode: aStringOrStream

	^ self parse: aStringOrStream! !

!PercentEncoding class methodsFor: 'converting' stamp: 'ess 11/3/2024 08:44:36'!
encode: aStringOrBytes

	| hexDigits bytes |

	hexDigits := `
		'0123456789ABCDEF' asByteArray
	`.

	bytes := aStringOrBytes isString
				ifTrue: [ aStringOrBytes asUtf8Bytes ]
				ifFalse: [ aStringOrBytes ].
	^ (ByteArray streamContents:
		[ :out |
		bytes do:
			[ :each |
			(self isUnreservedCodepoint: each)
				ifTrue: [ out nextPut: each ]
				ifFalse:
					[ out
						nextPut: `$% codePoint`;
						nextPut: (hexDigits at: each // 16 + 1);
						nextPut: (hexDigits at: each \\ 16 + 1) ] ] ])
			asString! !

!PercentEncoding class methodsFor: 'converting' stamp: 'ess 11/3/2024 07:50:28'!
normalize: anEncodedString

	^ self encode: (self decode: anEncodedString)! !

!PercentEncoding class methodsFor: 'testing' stamp: 'ess 11/3/2024 08:45:18'!
isUnreserved: aCharacter
	"Characters that are allowed in a URI but do not have a reserved purpose are called unreserved.  These include uppercase and lowercase letters, decimal digits, hyphen, period, underscore, and tilde.
	
	Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-2.3"
	
	^ self isUnreservedCodepoint: aCharacter codePoint! !

!PercentEncoding class methodsFor: 'testing' stamp: 'ess 11/2/2024 09:54:54'!
isUnreservedCodepoint: aCodePoint

	^ (aCodePoint
		between: `$- codePoint`
		and: `$~ codePoint`)
			and: [ self unreservedCodepoints at: aCodePoint ]! !

!URIParser methodsFor: 'constants' stamp: 'ess 1/8/2025 11:36:30'!
subDelimiters

	^'!!$&''()*+,;='! !

!URIParser methodsFor: 'parsing' stamp: 'ess 1/8/2025 13:26:02'!
parse

	uri scheme: self readScheme.
	self parseHierarchicalPart.
	(self match: $?) ifTrue:
		[uri query: self readQuery].
	(self match: $#) ifTrue:
		[uri fragment: self readFragment].
	^self didSucceed
		ifTrue: [uri]
		ifFalse: [nil]! !

!URIParser methodsFor: 'parsing' stamp: 'ess 1/8/2025 11:25:32'!
parse: aString into: aUri

	uri := aUri.
	^self parse: aString! !

!URIParser methodsFor: 'testing' stamp: 'ess 1/8/2025 13:23:55'!
isAlphaNumeric

	^self isAscii
		and: [lookahead isAlphaNumeric]! !

!URIParser methodsFor: 'testing' stamp: 'ess 1/8/2025 11:22:18'!
isHostnameCharacter

	^(self isUnreserved
		or: [self isSubDelimiter])
		or: [self isPercentEncoding]! !

!URIParser methodsFor: 'testing' stamp: 'ess 1/8/2025 13:24:01'!
isLetter

	^self isAscii
		and: [lookahead isLetter]! !

!URIParser methodsFor: 'testing' stamp: 'ess 1/8/2025 11:22:48'!
isNocolonPathCharacter

	^(lookahead ~~ $:)
		and: [self isPathCharacter]! !

!URIParser methodsFor: 'testing' stamp: 'ess 1/8/2025 11:23:01'!
isPathCharacter

	^(self isUnreserved
		or: [self isSubDelimiterOr: ':@'])
		or: [self isPercentEncoding]! !

!URIParser methodsFor: 'testing' stamp: 'ess 1/8/2025 13:24:52'!
isPercentEncoding
	"Answer true if lookahead is the start of a valid percent-encoded sequence."

	^lookahead == $% and:
		[self withSaveDo:
			[:reset | | a b |
			self consume.
			a := lookahead ifNotNil: [self consume asUppercase digitValue].
			b := lookahead ifNotNil: [self consume asUppercase digitValue].
			reset value.
			(a notNil and: [a between: 0 and: 15])
				and: [b notNil and: [b between: 0 and: 15]]]]! !

!URIParser methodsFor: 'testing' stamp: 'ess 1/8/2025 11:23:56'!
isQueryCharacter

	^self isPathCharacter
		or: ['/?' includes: lookahead]! !

!URIParser methodsFor: 'testing' stamp: 'ess 1/8/2025 11:24:04'!
isSchemeCharacter

	^self isAlphaNumeric
		or: ['+-.' includes: lookahead]! !

!URIParser methodsFor: 'testing' stamp: 'ess 1/8/2025 11:24:09'!
isSchemeStartCharacter

	^self isLetter! !

!URIParser methodsFor: 'testing' stamp: 'ess 1/8/2025 13:25:21'!
isSubDelimiter

	^self subDelimiters includes: lookahead! !

!URIParser methodsFor: 'testing' stamp: 'ess 1/8/2025 13:25:31'!
isSubDelimiterOr: otherAllowedCharacters

	^(self subDelimiters, otherAllowedCharacters) includes: lookahead! !

!URIParser methodsFor: 'testing' stamp: 'ess 1/8/2025 11:24:26'!
isUnreserved

	^lookahead notNil
		and: [PercentEncoding isUnreserved: lookahead]! !

!URIParser methodsFor: 'testing' stamp: 'ess 1/8/2025 11:24:44'!
isUserinfoCharacter

	^((lookahead == $:
		or: [self isUnreserved])
		or: [self isSubDelimiter])
		or: [self isPercentEncoding]! !

!URIParser methodsFor: 'private-authority' stamp: 'ess 1/8/2025 13:26:22'!
parseAuthority

	uri userinfo: self readUserinfo.
	uri host: self readHost.
	((self match: $:) and: [self isDigit]) ifTrue:
		[uri port: self readPort]! !

!URIParser methodsFor: 'private-authority' stamp: 'ess 1/8/2025 11:26:33'!
parseHierarchicalPart

	uri path:
		((self match: $/)
			ifTrue:
				[(self match: $/)
					ifFalse: [self readAbsolutePath]
					ifTrue:
						[self parseAuthority.
						(self match: $/)
							ifTrue: [self readAbsolutePath]
							ifFalse: [nil]]]
			ifFalse:
				[self isPathCharacter
					ifFalse: [nil]
					ifTrue:
						[uri scheme
						ifNotNil: [self readRelativePath]
						ifNil: [self readNoschemePath]]])! !

!URIParser methodsFor: 'private-authority' stamp: 'ess 1/8/2025 13:27:21'!
readHost

	lookahead == $[ ifTrue: [^self readIpLiteral].
	^self isDigit
		ifFalse: [self readHostname]
		ifTrue: [self readIPv4 ifNil: [self readHostname]]! !

!URIParser methodsFor: 'private-authority' stamp: 'ess 1/8/2025 11:29:03'!
readHostname

	^self readPercentEncodingSatisfying: [:la | self isHostnameCharacter]! !

!URIParser methodsFor: 'private-authority' stamp: 'ess 1/8/2025 13:27:59'!
readIPv4

	^self withSaveDo:
		[:reset |
		(1 to: 4) collect:
			[:each |
			each > 1 ifTrue:
				[(self match: $.) ifFalse:
					[reset value.
					^nil]].
				self readOctet ifNil:
					[reset value.
					^nil]]]! !

!URIParser methodsFor: 'private-authority' stamp: 'ess 1/8/2025 11:29:55'!
readIpLiteral

	"Not yet implemented."
	^nil! !

!URIParser methodsFor: 'private-authority' stamp: 'ess 1/8/2025 13:28:30'!
readOctet

	| octet |
	self isDigit ifFalse: [ nil ].
	octet := self consume digitValue.
	self isDigit ifTrue: [octet := octet * 10 + self consume digitValue].
	self isDigit ifTrue: [octet := octet * 10 + self consume digitValue].
	(octet between: 0 and: 255) ifFalse: [^nil].
	^octet! !

!URIParser methodsFor: 'private-authority' stamp: 'ess 1/8/2025 13:29:15'!
readPort

	| port |
	port := 0.
	[self isDigit] whileTrue:
		[port := port * 10 + self consume digitValue].
	(port between: 0 and: 65536) ifFalse: [^nil].
	^port! !

!URIParser methodsFor: 'private-miscellaneous' stamp: 'ess 1/8/2025 11:28:24'!
readFragment

	"Fragments accept the same characters as queries."
	^self readQuery! !

!URIParser methodsFor: 'private-miscellaneous' stamp: 'ess 1/8/2025 13:28:49'!
readPercentEncodingSatisfying: aBlock

	^String streamContents:
		[:stream |
		[aBlock value: lookahead] whileTrue:
			[(lookahead == $% and: [self isPercentEncoding])
				ifFalse: [stream nextPut: self consume]
				ifTrue: [3 timesRepeat: [stream nextPut: self consume]]]]! !

!URIParser methodsFor: 'private-miscellaneous' stamp: 'ess 1/8/2025 11:34:52'!
readQuery

	^self readPercentEncodingSatisfying: [:la | self isQueryCharacter]! !

!URIParser methodsFor: 'private-miscellaneous' stamp: 'ess 1/8/2025 13:29:42'!
readScheme

	self isSchemeStartCharacter ifFalse: [^nil].
	^self withSaveDo:
		[:reset | | scheme |
		scheme := String streamContents:
			[:stream |
			[self isSchemeCharacter] whileTrue:
				[stream nextPut: self consume]].
		(self match: $:)
			ifTrue: [scheme]
			ifFalse:
				[reset value.
				nil]]! !

!URIParser methodsFor: 'private-path' stamp: 'ess 1/8/2025 13:30:54'!
readAbsolutePath

	| firstSegment |
	firstSegment := self readPathSegment.
	firstSegment isEmpty ifTrue: [^URIPath root].
	^URIPath absolute: (self readPathSegmentsAfter: firstSegment)! !

!URIParser methodsFor: 'private-path' stamp: 'ess 1/8/2025 13:08:16'!
readNocolonPathSegment

	| segment |
	segment := self readPercentEncodingSatisfying: [:la | self isNocolonPathCharacter].
	segment isEmpty ifTrue: [URIParseError signal: 'Expected non-empty path segment'].
	^segment! !

!URIParser methodsFor: 'private-path' stamp: 'ess 1/8/2025 13:08:25'!
readNonemptyPathSegment

	self isPathCharacter ifFalse: [URIParseError signal: 'Expected non-empty path segment'].
	^self readPathSegment! !

!URIParser methodsFor: 'private-path' stamp: 'ess 1/8/2025 11:30:37'!
readNoschemePath

	^self readRelativePathAfter: self readNocolonPathSegment! !

!URIParser methodsFor: 'private-path' stamp: 'ess 1/8/2025 11:31:15'!
readPathSegment
	"May be empty."
	
	^self readPercentEncodingSatisfying: [:la | self isPathCharacter]! !

!URIParser methodsFor: 'private-path' stamp: 'ess 1/8/2025 11:31:38'!
readPathSegments

	| segments |
	segments := OrderedCollection with: self readPathSegment.
	[self match: $/] whileTrue:
		[segments add: self readPathSegment].
	^segments! !

!URIParser methodsFor: 'private-path' stamp: 'ess 1/8/2025 11:32:00'!
readPathSegmentsAfter: firstSegment

	| segments |
	segments := OrderedCollection with: firstSegment.
	(self match: $/) ifTrue:
		[segments addAll: self readPathSegments].
	^segments! !

!URIParser methodsFor: 'private-path' stamp: 'ess 1/8/2025 11:34:58'!
readRelativePath

	^self readRelativePathAfter: self readNonemptyPathSegment! !

!URIParser methodsFor: 'private-path' stamp: 'ess 1/8/2025 13:29:25'!
readRelativePathAfter: firstSegment

	^URIPath relative: (self readPathSegmentsAfter: firstSegment)! !

!URIParser methodsFor: 'private-path' stamp: 'ess 1/8/2025 13:29:52'!
readUserinfo

	^ self withSaveDo:
		[:reset | | userinfo |
		userinfo := self readPercentEncodingSatisfying: [:la | self isUserinfoCharacter].
		(self match: $@)
			ifTrue: [userinfo]
			ifFalse:
				[reset value.
				nil]]! !

!URIParser class methodsFor: 'parsing' stamp: 'ess 1/8/2025 13:23:26'!
parse: aString into: aUri

	^self new
		parse: aString
		into: aUri! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:14:42'!
authority

	^authority! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:14:51'!
authority: aUriAuthority

	authority := aUriAuthority! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:15:26'!
fragment

	^fragment! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:15:31'!
fragment: aString

	fragment := aString! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:15:49'!
host

	^authority ifNotNil: [authority host]! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:21:41'!
host: anObject

	self ensureAuthority host: anObject! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:16:34'!
password

	^authority ifNotNil: [authority password]! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:16:39'!
path

	^path! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:16:47'!
path: aUriPath

	path := aUriPath! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:16:57'!
port

	^authority ifNotNil: [authority port]! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:22:08'!
port: anInteger

	self ensureAuthority port: anInteger! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:18:12'!
query

	^query! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 14:05:00'!
query: anObject

	| queryDictionary |
	(anObject isNil or: [anObject isString]) ifTrue:
		[query := anObject.
		^self].
	queryDictionary := QueryDictionary newFrom: anObject.
	query := queryDictionary asQueryString! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 14:15:45'!
queryDictionary

	^query ifNotNil: [QueryDictionary fromString: query]! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:19:54'!
scheme

	^scheme! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:19:59'!
scheme: aString

	scheme := aString! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:20:11'!
userinfo

	^authority ifNotNil: [authority userinfo]! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:22:28'!
userinfo: aString

	self ensureAuthority userinfo: aString! !

!URI methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:20:35'!
username

	^authority ifNotNil: [authority username]! !

!URI methodsFor: 'comparing' stamp: 'ess 1/8/2025 13:14:14'!
= anotherUri

	self == anotherUri ifTrue: [^true].
	(anotherUri is: #URI) ifFalse: [^false].
	^((((scheme == anotherUri scheme)
			and: [authority == anotherUri authority])
			and: [path == anotherUri path])
			and: [query == anotherUri query])
			and: [fragment == anotherUri fragment]! !

!URI methodsFor: 'comparing' stamp: 'ess 1/8/2025 11:45:54'!
hash

	^{scheme. authority. path. query. fragment}
		inject: self class hash
		into: [:sum :each | sum bitXor: each hash]! !

!URI methodsFor: 'converting' stamp: 'ess 1/8/2025 13:14:32'!
asNormal

	^self copy
		beNormal;
		yourself! !

!URI methodsFor: 'converting' stamp: 'ess 1/8/2025 13:15:20'!
beNormal

	scheme := scheme ifNotNil: [scheme asLowercase].
	authority := authority ifNotNil: [authority asNormal].
	path := path ifNotNil: [path asNormal].
	query := query ifNotNil: [PercentEncoding normalize: query].
	fragment := fragment ifNotNil: [PercentEncoding normalize: fragment]! !

!URI methodsFor: 'converting' stamp: 'ess 1/8/2025 13:19:49'!
relativeTo: aBaseUri
	"Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-5.2"

	| target |
	target := self species new.
	target fragment: fragment.

	scheme ifNotNil:
		[target
			scheme: scheme;
			authority: authority;
			path: (path ifNotNil: [path withoutDotSegments]);
			query: query.
		^target].
	target scheme: aBaseUri scheme.

	authority ifNotNil:
		[target
			authority: authority;
			path: (path ifNotNil: [path withoutDotSegments]);
			query: query.
		^target].	
	target authority: aBaseUri authority.

	path ifNil:
		[target
			path: aBaseUri path;
			query: (query ifNil: [aBaseUri query]).
		^target].
	target query: query.

	target path:
		(path isAbsolute
			ifTrue: [path withoutDotSegments]
			ifFalse: [path relativeTo: aBaseUri path]).
	^target! !

!URI methodsFor: 'printing' stamp: 'ess 1/8/2025 13:17:56'!
printOn: aStream
	"Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-5.3"

	scheme ifNotNil:
		[aStream
			nextPutAll: scheme;
			nextPut: $:].
	authority ifNotNil:
		[aStream
			nextPutAll: '//';
			nextPutAll: authority asString].
	path ifNotNil:
		[aStream nextPutAll: path asString].
	query ifNotNil:
		[aStream
			nextPut: $?;
			nextPutAll: query].
	fragment ifNotNil:
		[aStream
			nextPut: $#;
			nextPutAll: fragment]! !

!URI methodsFor: 'testing' stamp: 'ess 1/8/2025 13:16:22'!
is: aSymbol

	^aSymbol == #URI or: [super is: aSymbol]! !

!URI methodsFor: 'private' stamp: 'ess 1/8/2025 13:21:12'!
ensureAuthority

	^authority ifNil: [authority := URIAuthority new]! !

!URI class methodsFor: 'instance creation' stamp: 'ess 1/8/2025 13:23:05'!
fromString: aString

	^URIParser
		parse: aString
		into: self new! !

!URIAuthority methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:10:51'!
host

	^host! !

!URIAuthority methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:10:58'!
host: anObject

	host := anObject! !

!URIAuthority methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:11:39'!
password

	^userinfo ifNotNil:
		[| separator |
		separator := userinfo indexOf: $:.
		separator = 0
			ifTrue: [nil]
			ifFalse:
				[userinfo
					copyFrom: separator + 1
					to: userinfo size]]! !

!URIAuthority methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:11:55'!
port

	^port! !

!URIAuthority methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:12:04'!
port: anInteger

	port := anInteger! !

!URIAuthority methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:12:37'!
userinfo

	^userinfo! !

!URIAuthority methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:12:45'!
userinfo: aString

	userinfo := aString! !

!URIAuthority methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:13:07'!
username

	^userinfo ifNotNil:
		[| separator |
		separator := userinfo indexOf: $:.
		separator = 0
			ifTrue: [nil]
			ifFalse:
				[userinfo
					copyFrom: 1
					to: separator - 1]]! !

!URIAuthority methodsFor: 'comparing' stamp: 'ess 1/8/2025 13:10:27'!
= anotherUriAuthority

	self == anotherUriAuthority ifTrue: [^true].
	(anotherUriAuthority is: #URIAuthority) ifFalse: [^false].
	^((userinfo = anotherUriAuthority userinfo)
		and: [host = anotherUriAuthority host])
		and: [port = anotherUriAuthority port]! !

!URIAuthority methodsFor: 'comparing' stamp: 'ess 1/8/2025 13:09:38'!
hash

	^((self class hash
		bitXor: userinfo hash)
		bitXor: host hash)
		bitXor: port hash! !

!URIAuthority methodsFor: 'converting' stamp: 'ess 1/8/2025 13:09:49'!
asNormal

	^self copy
		beNormal;
		yourself! !

!URIAuthority methodsFor: 'converting' stamp: 'ess 1/8/2025 13:10:12'!
beNormal

	userinfo := userinfo ifNotNil: [PercentEncoding normalize: userinfo].
	(host notNil and: [host isString]) ifTrue:
		[host := host asLowercase]! !

!URIAuthority methodsFor: 'printing' stamp: 'ess 1/8/2025 13:18:06'!
printOn: aStream

	userinfo ifNotNil:
		[aStream
			nextPutAll: userinfo;
			nextPut: $@].
	host ifNotNil:
		[aStream nextPutAll: host].
	port ifNotNil:
		[aStream
			nextPut: $:;
			print: port]! !

!URIAuthority methodsFor: 'testing' stamp: 'ess 1/8/2025 13:11:10'!
is: aSymbol

	^aSymbol == #URIAuthority or: [super is: aSymbol]! !

!URIPath methodsFor: 'accessing' stamp: 'ess 1/8/2025 13:02:10'!
segments
	"Can be nil for an empty path."

	^segments! !

!URIPath methodsFor: 'comparing' stamp: 'ess 1/8/2025 11:52:33'!
= anotherPath

	self == anotherPath ifTrue: [^true].
	(anotherPath is: #URIPath) ifFalse: [^false].
	^(isAbsolute = anotherPath isAbsolute)
		and: [segments = anotherPath segments]! !

!URIPath methodsFor: 'comparing' stamp: 'ess 1/8/2025 11:47:58'!
hash

	^(self class hash
		bitXor: isAbsolute hash)
		bitXor: segments hash! !

!URIPath methodsFor: 'converting' stamp: 'ess 1/8/2025 11:48:34'!
asNormal

	^self copy
		beNormal;
		yourself! !

!URIPath methodsFor: 'converting' stamp: 'ess 1/8/2025 11:49:05'!
beNormal
	"Normalize internal representation.
	Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.3"

	segments := segments ifNotNil:
		[segments collect: [:each | PercentEncoding normalize: each]].
	self removeDotSegments! !

!URIPath methodsFor: 'converting' stamp: 'ess 1/8/2025 11:51:51'!
relativeTo: aBasePath
	"Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-5.2"

	(aBasePath isNil or: [aBasePath segments isNil]) ifTrue: [^self withoutDotSegments].
	^(self species new
		setSegments: aBasePath segments allButLast, segments
		isAbsolute: aBasePath isAbsolute)
			withoutDotSegments! !

!URIPath methodsFor: 'converting' stamp: 'ess 1/8/2025 13:36:23'!
removeDotSegments
	"Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4"

	| isDirectory result |
	segments ifNil: [^self].

	"Track if the last component added to result should be interpreted as a directory reference."
	isDirectory := false.
	result := OrderedCollection new.
	segments do:
		[:each |
		(each = '..' and: [result notEmpty]) ifTrue: [result removeLast].
		isDirectory := each = '..' | (each = '.').
		isDirectory ifFalse: [result addLast: each]].

	"Add an empty path segment to show that result is a directory."
	isDirectory ifTrue: [result addLast: ''].

	segments := result! !

!URIPath methodsFor: 'converting' stamp: 'ess 1/8/2025 13:01:47'!
withoutDotSegments

	^self copy
		removeDotSegments;
		yourself! !

!URIPath methodsFor: 'printing' stamp: 'ess 1/8/2025 11:51:20'!
printOn: aStream

	isAbsolute ifTrue: [aStream nextPut: $/].
	segments
		do: [:each | aStream nextPutAll: each]
		separatedBy: [aStream nextPut: $/]! !

!URIPath methodsFor: 'testing' stamp: 'ess 1/8/2025 11:49:46'!
is: aSymbol

	^aSymbol == #URIPath or: [super is: aSymbol]! !

!URIPath methodsFor: 'testing' stamp: 'ess 1/8/2025 11:50:01'!
isAbsolute

	^isAbsolute! !

!URIPath methodsFor: 'testing' stamp: 'ess 1/8/2025 11:50:33'!
isDirectory
	"Am I a directory reference?"

	"We represent directories with a final empty segment."
	^segments isEmptyOrNil not
		and: [segments last isEmpty]! !

!URIPath methodsFor: 'testing' stamp: 'ess 1/8/2025 11:50:42'!
isEmpty
	"Do I represent an empty path?"

	"Segments notNil and isEmpty denotes the root path '/' "
	^segments isNil! !

!URIPath methodsFor: 'testing' stamp: 'ess 1/8/2025 11:50:51'!
isRelative

	^isAbsolute not! !

!URIPath methodsFor: 'testing' stamp: 'ess 1/8/2025 11:50:57'!
notEmpty

	^segments notNil! !

!URIPath methodsFor: 'private' stamp: 'ess 1/8/2025 13:01:57'!
setSegments: pathSegments isAbsolute: aBoolean

	segments := pathSegments.
	isAbsolute := aBoolean.
	^self! !

!URIPath class methodsFor: 'instance creation' stamp: 'ess 1/8/2025 13:07:04'!
absolute: pathSegments

	^self new
		setSegments: pathSegments
		isAbsolute: true! !

!URIPath class methodsFor: 'instance creation' stamp: 'ess 1/8/2025 13:07:09'!
empty

	^self new
		setSegments: nil
		isAbsolute: false! !

!URIPath class methodsFor: 'instance creation' stamp: 'ess 1/8/2025 13:07:14'!
relative: pathSegments

	^self new
		setSegments: pathSegments
		isAbsolute: false! !

!URIPath class methodsFor: 'instance creation' stamp: 'ess 1/8/2025 13:06:55'!
root

	^self new
		setSegments: OrderedCollection new
		isAbsolute: true! !

!ByteArray methodsFor: '*URI-converting' stamp: 'ess 11/3/2024 08:49:47'!
percentEncoded

	^ PercentEncoding encode: self! !

!CharacterSequence methodsFor: '*URI-converting' stamp: 'ess 11/3/2024 08:48:56'!
percentDecoded

	^ PercentEncoding decode: self! !

!CharacterSequence methodsFor: '*URI-converting' stamp: 'ess 11/3/2024 08:48:31'!
percentEncoded

	^ PercentEncoding encode: self! !

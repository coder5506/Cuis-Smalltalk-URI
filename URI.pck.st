'From Cuis7.3 [latest update: #6971] on 7 January 2025 at 2:21:28 pm'!
'Description '!
!provides: 'URI' 1 1!
SystemOrganization addCategory: #URI!
SystemOrganization addCategory: #'URI-Public'!
SystemOrganization addCategory: #'URI-Tests'!


!classDefinition: #MultiDictionary category: #'URI-Public'!
OrderedCollection subclass: #MultiDictionary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'MultiDictionary class' category: #'URI-Public'!
MultiDictionary class
	instanceVariableNames: ''!

!classDefinition: #QueryDictionary category: #'URI-Public'!
MultiDictionary subclass: #QueryDictionary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'QueryDictionary class' category: #'URI-Public'!
QueryDictionary class
	instanceVariableNames: ''!

!classDefinition: #ParseError category: #'URI-Public'!
Error subclass: #ParseError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'ParseError class' category: #'URI-Public'!
ParseError class
	instanceVariableNames: ''!

!classDefinition: #URIParseError category: #'URI-Public'!
Error subclass: #URIParseError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'URIParseError class' category: #'URI-Public'!
URIParseError class
	instanceVariableNames: ''!

!classDefinition: #TestPercentEncoding category: #'URI-Tests'!
TestCase subclass: #TestPercentEncoding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Tests'!
!classDefinition: 'TestPercentEncoding class' category: #'URI-Tests'!
TestPercentEncoding class
	instanceVariableNames: ''!

!classDefinition: #TestURI category: #'URI-Tests'!
TestCase subclass: #TestURI
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Tests'!
!classDefinition: 'TestURI class' category: #'URI-Tests'!
TestURI class
	instanceVariableNames: ''!

!classDefinition: #TestURIPath category: #'URI-Tests'!
TestCase subclass: #TestURIPath
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Tests'!
!classDefinition: 'TestURIPath class' category: #'URI-Tests'!
TestURIPath class
	instanceVariableNames: ''!

!classDefinition: #BaseParser category: #'URI-Public'!
Object subclass: #BaseParser
	instanceVariableNames: 'input lookahead shift'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'BaseParser class' category: #'URI-Public'!
BaseParser class
	instanceVariableNames: ''!

!classDefinition: #PercentEncoding category: #'URI-Public'!
BaseParser subclass: #PercentEncoding
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'PercentEncoding class' category: #'URI-Public'!
PercentEncoding class
	instanceVariableNames: ''!

!classDefinition: #URIParser category: #'URI-Public'!
BaseParser subclass: #URIParser
	instanceVariableNames: 'uri'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'URIParser class' category: #'URI-Public'!
URIParser class
	instanceVariableNames: ''!

!classDefinition: #URI category: #'URI-Public'!
Object subclass: #URI
	instanceVariableNames: 'scheme authority path query fragment'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'URI class' category: #'URI-Public'!
URI class
	instanceVariableNames: ''!

!classDefinition: #URIAuthority category: #'URI-Public'!
Object subclass: #URIAuthority
	instanceVariableNames: 'userinfo host port'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'URIAuthority class' category: #'URI-Public'!
URIAuthority class
	instanceVariableNames: ''!

!classDefinition: #URIPath category: #'URI-Public'!
Object subclass: #URIPath
	instanceVariableNames: 'segments isAbsolute'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'URI-Public'!
!classDefinition: 'URIPath class' category: #'URI-Public'!
URIPath class
	instanceVariableNames: ''!


!MultiDictionary commentStamp: '<historical>' prior: 0!
Part Dictionary, part Bag, slower than both (well, either).

I am a dictionary that allows multiple values for a key.  I am meant to be used for tasks such as interpreting a query string or the contents of an application/x-www-form-urlencoded post, or storing MIME headers.  I support case-insensitive lookups when using String keys.

To support my tasks, I also track order of key insertion.
!

!ParseError commentStamp: 'ess 11/19/2024 09:53:48' prior: 0!
I am a class for errors generated by BaseParser.!

!BaseParser commentStamp: 'ess 11/19/2024 10:23:00' prior: 0!
I am a utility for writing recursive-descent parsers.

I have a single-token lookahead, but I also support backtracking.  I differ from Parser in not being specific to Smalltalk.

I am little more than a thin wrapper around a PositionableStream, i.e., my #lookahead equates to a stream's #peek and my #consume equates to a stream's #next.

My main differenece from a stream is my #step method, which supports mapping one or more items from the underlying collection as a single token.  For many uses, this allows you to write parsers without having separate tokenization and parsing stages.  (This is sometimes convenient, and sometimes necessary.)  To do the same using only a stream can require distracting bookkeeping of the stream's underlying position.

To avoid that bookkeeping, I provide the methods #save and #restore to save and restore, respectively, the stream's position.  Saved positions can be nested.  To implement backtracking or multi-token lookahead, use #withSaveDo: to manage all this.

I also provide a number of convenience methods that map directly to tests of the #lookahead token, but check for end-of-input, i.e., #isDigit is equivalent to `lookahead notNil and: [ lookahead isDigit ]`.!

!PercentEncoding commentStamp: '<historical>' prior: 0!
Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-2.1!

!URIAuthority commentStamp: '<historical>' prior: 0!
Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-3.2!

!URIPath commentStamp: '<historical>' prior: 0!
I am the path component of an RFC3986 URI.!

!MultiDictionary methodsFor: 'accessing' stamp: 'ess 11/3/2024 16:04:48'!
allAt: aKey

	^ super collect: [ :each | each key = aKey ifTrue: [ each value ] ]! !

!MultiDictionary methodsFor: 'accessing' stamp: 'ess 11/3/2024 16:05:02'!
allAt: aKey ifAbsent: exceptionBlock

	| result |
	result := self allAt: aKey.
	^ result isEmpty
		ifFalse: [ result ]
		ifTrue: [ exceptionBlock value ]! !

!MultiDictionary methodsFor: 'accessing' stamp: 'ess 11/3/2024 16:05:31'!
at: aKey

	^ self
		at: aKey
		ifAbsent: [ nil ]! !

!MultiDictionary methodsFor: 'accessing' stamp: 'ess 11/3/2024 16:05:43'!
at: aKey ifAbsent: exceptionBlock

	^ super
		detect: [ :each | each key = aKey ]
		ifFound: [ :item | item value ]
		ifNone: exceptionBlock! !

!MultiDictionary methodsFor: 'accessing' stamp: 'ess 11/3/2024 16:17:35'!
at: aKey put: aValue

	firstIndex to: lastIndex do:
		[ :index | | each |
		each := array at: index.
		each key = aKey
			ifTrue:
				[ array
					at: index
					put: each key -> aValue.
				^ aValue ] ].
	
	^ self
		at: aKey
		putNew: aValue! !

!MultiDictionary methodsFor: 'accessing' stamp: 'ess 11/3/2024 16:17:42'!
at: aKey putNew: aValue

	super addLast: aKey -> aValue.
	^ aValue! !

!MultiDictionary methodsFor: 'enumerating' stamp: 'ess 11/3/2024 13:26:44'!
associationsDo: aBlock
	"Evaluate aBlock for each of the receiver's key/value associations."

	super do: aBlock! !

!MultiDictionary methodsFor: 'enumerating' stamp: 'ess 11/3/2024 16:21:53'!
collect: aBlock 
	"Evaluate aBlock with each of my values as the argument.  Collect the resulting values into a collection that is like me. Answer with the new collection."
	
	^ super collect: [ :each | each key -> (aBlock value: each value) ]! !

!MultiDictionary methodsFor: 'enumerating' stamp: 'ess 11/3/2024 13:27:23'!
do: aBlock

	super do: [:assoc | aBlock value: assoc value]! !

!MultiDictionary methodsFor: 'enumerating' stamp: 'ess 11/3/2024 16:23:04'!
keysAndValuesDo: aBlock

	^self associationsDo:
			[ :each |
			aBlock
				value: each key
				value: each value ].! !

!MultiDictionary methodsFor: 'enumerating' stamp: 'ess 11/3/2024 16:22:25'!
keysDo: aBlock 
	"Evaluate aBlock for each of the receiver's keys."

	self associationsDo: [ :each | aBlock value: each key]! !

!MultiDictionary methodsFor: 'enumerating' stamp: 'ess 11/3/2024 16:22:15'!
reverseDo: aBlock
	"Evaluate aBlock for each of the receiver's values in reverse order."

	super reverseDo: [ :each | aBlock value: each value]! !

!MultiDictionary methodsFor: 'enumerating' stamp: 'ess 11/3/2024 16:21:46'!
select: aBlock 
	"Evaluate aBlock with each of my values as the argument.  Collect into a new  dictionary, only those associations for which aBlock evaluates to true."
	
	^ super select: [ :each | aBlock value: each value ]! !

!MultiDictionary methodsFor: 'enumerating' stamp: 'ess 11/3/2024 16:22:05'!
valuesDo: aBlock 
	"Evaluate aBlock for each of the receiver's keys."

	self associationsDo: [ :each | aBlock value: each value]! !

!QueryDictionary methodsFor: 'converting' stamp: 'ess 11/4/2024 03:53:56'!
asQueryString

	^ String streamContents:
				[ :out |
				super
					do: [ :each |
						out nextPutAll: each key percentEncoded.
						each value
							ifNotNil:
								[ out
									nextPut: $=;
									nextPutAll: each value percentEncoded ] ]		
					separatedBy: [ out nextPut: $& ] ]! !

!QueryDictionary methodsFor: 'private' stamp: 'ess 11/4/2024 03:53:43'!
setQueryString: aString

	(aString findTokens: '&')
		do: [ :each | | separator key value |
			separator := each indexOf: $=.
			separator isZero
				ifTrue:
					[ key := each.
					self
						at: key percentDecoded
						putNew: nil ]
				ifFalse:
					[ key := each
							copyFrom: 1
							to: separator - 1.
					value := each
							copyFrom: separator + 1
							to: each size.
					self
						at: key percentDecoded
						putNew: value percentDecoded ] ].
	^ self! !

!QueryDictionary class methodsFor: 'instance creation' stamp: 'ess 11/4/2024 03:54:30'!
fromString: aString

	^ self new
		setQueryString: aString! !

!TestPercentEncoding methodsFor: 'tests' stamp: 'ess 11/3/2024 08:50:31'!
testEncoding1

	| decoded encoded |
	
	decoded := 'öb-a~da_A.Z'.
	encoded := '%C3%B6b-a~da_A.Z'.
	
	self
		assert: (PercentEncoding decode: encoded)
		equals: decoded.
	self
		assert: (PercentEncoding encode: decoded)
		equals: encoded! !

!TestPercentEncoding methodsFor: 'tests' stamp: 'ess 11/3/2024 08:50:53'!
testEncoding2

	| decoded encoded |

	decoded := 'ほんとうにながいわけのわからないどめいんめいのらべるまだながくしないとたりない.ほんとうにながいわけのわからないどめいんめいのらべるまだながくしないとたりない.ほんとうにながいわけのわからないどめいんめいのらべるまだながくしないとたりない.w3.mag.keio.ac.jp'.

	encoded := '%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%9F%E3%82%8A%E3%81%AA%E3%81%84.%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%9F%E3%82%8A%E3%81%AA%E3%81%84.%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%9F%E3%82%8A%E3%81%AA%E3%81%84.w3.mag.keio.ac.jp'.
	
	self
		assert: (PercentEncoding decode: encoded)
		equals: decoded.
	self
		assert: (PercentEncoding encode: decoded)
		equals: encoded! !

!TestPercentEncoding methodsFor: 'tests' stamp: 'ess 11/3/2024 08:53:01'!
testNormalization
	"From https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2"

	self
		assert: (PercentEncoding normalize: '%7bfoo%7d')
		equals: '%7Bfoo%7D'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/5/2024 04:56:12'!
skipExample3
	"This test is broken because IPv6 parsing is not yet implemented."

	| uri |
	
	uri := URI fromString: 'ldap://[2001:db8::7]/c=GB?objectClass?one'.
	self
		assert: uri scheme
		equals: 'ldap'.
	self
		assert: uri host
		equals: '[2001:db8::7]'.
	self
		assert: uri path asString
		equals: 'c=GB'.
	self
		assert: uri query
		equals: 'objectClass?one'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/4/2024 05:50:00'!
testExample2
	"Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-1.1.2"

	| uri |
	
	uri := URI fromString: 'http://www.ietf.org/rfc/rfc2396.txt'.
	self
		assert: uri scheme
		equals: 'http'.
	self
		assert: uri host
		equals: 'www.ietf.org'.
	self
		assert: uri path asString
		equals: '/rfc/rfc2396.txt'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/2/2024 04:54:39'!
testExample4

	| uri |
	
	uri := URI fromString: 'mailto:John.Doe@example.com'.
	self
		assert: uri scheme
		equals: 'mailto'.
	self
		assert: uri path segments first
		equals: 'John.Doe@example.com'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/2/2024 04:52:35'!
testExample5

	| uri |
	
	uri := URI fromString: 'news:comp.infosystems.www.servers.unix'.
	self
		assert: uri path segments first
		equals: 'comp.infosystems.www.servers.unix'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/2/2024 04:54:51'!
testExample6

	| uri |
	
	uri := URI fromString: 'tel:+1-816-555-1212'.
	self
		assert: uri path asString
		equals: '+1-816-555-1212'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/1/2024 14:37:37'!
testExample7

	| uri |
	
	uri := URI fromString: 'telnet://192.0.2.16:80'.
	self
		assert: uri scheme
		equals: 'telnet'.
	self
		assert: uri host
		equals: #(192 0 2 16).
	self
		assert: uri port
		equals: 80! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/2/2024 04:50:24'!
testExample8

	| uri |
	
	uri := URI fromString: 'urn:oasis:names:specification:docbook:dtd:xml:4.1.2'.
	self
		assert: uri scheme
		equals: 'urn'.
	self
		assert: uri path asString
		equals: 'oasis:names:specification:docbook:dtd:xml:4.1.2'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/1/2024 14:49:06'!
testExample9

	| uri |
	
	uri := URI fromString: 'foo://example.com:8042/over/there?name=ferret#nose'.
	self
		assert: uri scheme
		equals: 'foo'.
	self
		assert: uri host
		equals: 'example.com'.
	self
		assert: uri port
		equals: 8042.
	self
		assert: uri path asString
		equals: '/over/there'.
	self
		assert: uri query
		equals: 'name=ferret'.
	self
		assert: uri fragment
		equals: 'nose'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/3/2024 09:24:02'!
testFileUri1
	"From Cuis-Smalltalk-URI-Kernel"
	
	| uri |

	uri := URI fromString: 'file:///path/to/file'.
	self
		assert: uri scheme
		equals: 'file'.
	self
		assert: uri path asString
		equals: '/path/to/file'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/3/2024 09:24:08'!
testFileUri2

	| uri |

	uri := URI fromString: 'file:/path/to/file'.
	self
		assert: uri path asString
		equals: '/path/to/file'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/3/2024 09:24:13'!
testFileUri3

	| uri |

	uri := URI fromString: 'file://host.example.com/path/to/file'.
	self
		assert: uri scheme
		equals: 'file'.
	self
		assert: uri host
		equals: 'host.example.com'.
	self
		assert: uri path asString
		equals: '/path/to/file'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/3/2024 09:24:21'!
testFileUri4

	| uri |
	
	uri := URI fromString: 'file://hostname/path/to/the%20file.txt'.
	self
		assert: uri path segments last
		equals: 'the%20file.txt'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/3/2024 09:23:45'!
testFileUri5

	| uri |
	
	uri := URI fromString: 'file:///c:/path/to/the%20file.txt'.
	self
		assert: uri path asString
		equals: '/c:/path/to/the%20file.txt'.
	self
		assert: uri path segments last
		equals: 'the%20file.txt'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/3/2024 09:24:40'!
testFranz1
	"From https://github.com/llibra/puri"

	| uri |
	
	uri := URI fromString: 'http://www.franz.com/a/b;x;y;z/c/foo?bar=baz&xxx#foo'.
	self
		assert: uri path asString
		equals: '/a/b;x;y;z/c/foo'.
	self
		assert: uri query
		equals: 'bar=baz&xxx'.
	self
		assert: uri fragment
		equals: 'foo'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/2/2024 04:42:34'!
testFranz2

	| uri |
	
	uri := URI fromString: 'http://www.franz.com/a/b;x;y;z/c/%2ffoo?bar=baz&xxx#foo'.
	self
		assert: uri path asString
		equals: '/a/b;x;y;z/c/%2ffoo'.
	self
		assert: uri path segments last
		equals: '%2ffoo'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/3/2024 09:24:48'!
testFromString1
	"From Cuis-Smalltalk-URI-Kernel"

	| uri |

	uri := URI fromString: 'https://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top'.
	
	self
		assert: uri scheme
		equals: 'https'.
	self
		assert: uri userinfo
		equals: 'john.doe'.
	self
		assert: uri host
		equals: 'www.example.com'.
	self
		assert: uri port
		equals: 123.
	self
		assert: uri authority asString
		equals: 'john.doe@www.example.com:123'.
	self
		assert: uri path asString
		equals: '/forum/questions/'.
	self
		assert: uri query
		equals: 'tag=networking&order=newest'.
	self
		assert: uri fragment
		equals: 'top'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/3/2024 09:24:56'!
testFromString2

	| uri |

	uri := URI fromString: 'http://a/b/c/d;p?q'.
	
	self
		assert: uri host
		equals: 'a'.
	self assert: uri path isAbsolute.
	self
		assert: uri path asString
		equals: '/b/c/d;p'.
	self
		assert: uri query
		equals: 'q'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/3/2024 09:25:04'!
testFromString8

	| uri |

	uri := URI fromString: '../../../g'.
	
	self assert: uri path isRelative.
	self
		assert: uri path asString
		equals: '../../../g'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/3/2024 09:21:16'!
testLongUri

	| uri expectedHost uriString |
	
	expectedHost := '%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%9F%E3%82%8A%E3%81%AA%E3%81%84.%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%9F%E3%82%8A%E3%81%AA%E3%81%84.%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%9F%E3%82%8A%E3%81%AA%E3%81%84.w3.mag.keio.ac.jp'.

	uriString := 'http://%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%9F%E3%82%8A%E3%81%AA%E3%81%84.%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%9F%E3%82%8A%E3%81%AA%E3%81%84.%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3%81%9F%E3%82%8A%E3%81%AA%E3%81%84.w3.mag.keio.ac.jp/'.
	
	uri := URI fromString: uriString.
	
	self
		assert: uri host
		equals: expectedHost! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/3/2024 09:31:43'!
testPostgresUri1
	"From Cuis-Smalltalk-URI-Kernel"

	| uri |
	
	uri := URI fromString: 'postgresql://'.
	self
		assert: uri scheme
		equals: 'postgresql'.
	self assert: uri path isNil! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/3/2024 09:22:14'!
testPostgresUri2

	| uri |
	
	uri := URI fromString: 'postgresql://localhost'.
	self
		assert: uri scheme
		equals: 'postgresql'.
	self
		assert: uri host
		equals: 'localhost'.
	self assert: uri path isNil! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/3/2024 09:22:08'!
testPostgresUri3

	| uri |
	
	uri := URI fromString: 'postgresql://localhost:5433'.
	self
		assert: uri host
		equals: 'localhost'.
	self
		assert: uri port
		equals: 5433.
	self assert: uri path isNil! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/3/2024 09:22:00'!
testPostgresUri4

	| uri |
	
	uri := URI fromString: 'postgresql://localhost/mydb'.
	self
		assert: uri path segments first
		equals: 'mydb'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/3/2024 09:21:53'!
testPostgresUri5

	| uri |
	
	uri := URI fromString: 'postgresql://user@localhost'.
	self
		assert: uri userinfo
		equals: 'user'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/3/2024 09:21:47'!
testPostgresUri6

	| uri |
	
	uri := URI fromString: 'postgresql://user:secret@localhost'.
	self
		assert: uri userinfo
		equals: 'user:secret'! !

!TestURI methodsFor: 'tests' stamp: 'ess 11/3/2024 09:21:41'!
testPostgresUri7

	| uri |
	
	uri := URI fromString: 'postgresql://other@localhost/otherdb?connect_timeout=10&application_name=myapp'.
	self
		assert: uri userinfo
		equals: 'other'.
	self
		assert: uri path segments first
		equals: 'otherdb'.
	self
		assert: uri query
		equals: 'connect_timeout=10&application_name=myapp'! !

!TestURIPath methodsFor: 'tests' stamp: 'ess 11/3/2024 09:18:28'!
testAbormalExamples
	"Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-5.4.2"
	
	| baseUri |

	baseUri := URI fromString: 'http://a/b/c/d;p?q'.

	{
		'../../../g' -> 'http://a/g' .
		'../../../../g' -> 'http://a/g' .
		'/./g' -> 'http://a/g' .
		'/../g' -> 'http://a/g' .
		'g.' -> 'http://a/b/c/g.' .
		'.g' -> 'http://a/b/c/.g' .
		'g..' -> 'http://a/b/c/g..' .
		'..g' -> 'http://a/b/c/..g' .
		'./../g' -> 'http://a/b/g' .
		'./g/.' -> 'http://a/b/c/g/' .
		'g/./h' -> 'http://a/b/c/g/h' .
		'g/../h' -> 'http://a/b/c/h' .
		'g;x=1/./y' -> 'http://a/b/c/g;x=1/y' .
		'g;x=1/../y' -> 'http://a/b/c/y' .
		'g?y/./x' -> 'http://a/b/c/g?y/./x' .
		'g?y/../x' -> 'http://a/b/c/g?y/../x' .
		'g#s/./x' -> 'http://a/b/c/g#s/./x' .
		'g#s/../x' -> 'http://a/b/c/g#s/../x' .
		'http:g' -> 'http:g'
	} do:
		[ :each | | relativeUri targetUri |
		relativeUri := URI fromString: each key.
		targetUri := relativeUri relativeTo: baseUri.
		self
			assert: targetUri asString
			equals: each value ]! !

!TestURIPath methodsFor: 'tests' stamp: 'ess 11/3/2024 09:18:45'!
testNormalExamples
	"Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-5.4.1"
	
	| baseUri |

	baseUri := URI fromString: 'http://a/b/c/d;p?q'.

	{
		'g:h' -> 'g:h' .
		'g' -> 'http://a/b/c/g' .
		'./g' -> 'http://a/b/c/g' .
		'g/' -> 'http://a/b/c/g/' .
		'/g' -> 'http://a/g' .
		'//g' -> 'http://g' .
		'?y' -> 'http://a/b/c/d;p?y' .
		'g?y' -> 'http://a/b/c/g?y' .
		'#s' -> 'http://a/b/c/d;p?q#s' .
		'g#s' -> 'http://a/b/c/g#s' .
		'g?y#s' -> 'http://a/b/c/g?y#s' .
		';x' -> 'http://a/b/c/;x' .
		'g;x' -> 'http://a/b/c/g;x' .
		'g;x?y#s' -> 'http://a/b/c/g;x?y#s' .
		'' -> 'http://a/b/c/d;p?q' .
		'.' -> 'http://a/b/c/' .
		'./' -> 'http://a/b/c/' .
		'..' -> 'http://a/b/' .
		'../' -> 'http://a/b/' .
		'../g' -> 'http://a/b/g' .
		'../..' -> 'http://a/' .
		'../../' -> 'http://a/' . 
		'../../g' -> 'http://a/g'
	} do:
		[ :each | | relativeUri targetUri |
		relativeUri := URI fromString: each key.
		targetUri := relativeUri relativeTo: baseUri.
		self
			assert: targetUri asString
			equals: each value ]! !

!TestURIPath methodsFor: 'tests' stamp: 'ess 11/3/2024 09:19:07'!
testWithoutDotSegments1

	| originalPath reducedPath |
	
	originalPath := URIPath absolute: #('a' 'b' 'c' '.' '..' '..' 'g').
	reducedPath := originalPath withoutDotSegments.
	
	self
		assert: reducedPath asString
		equals: '/a/g'! !

!TestURIPath methodsFor: 'tests' stamp: 'ess 11/3/2024 09:19:12'!
testWithoutDotSegments2

	| originalPath reducedPath |
	
	originalPath := URIPath relative: #('mid' 'content=5' '..' '6').
	reducedPath := originalPath withoutDotSegments.
	
	self
		assert: reducedPath asString
		equals: 'mid/6'! !

!BaseParser methodsFor: 'accessing' stamp: 'ess 11/3/2024 08:41:05'!
input: aStringOrStream

	input := aStringOrStream readStream.
	self step! !

!BaseParser methodsFor: 'backtracking' stamp: 'ess 11/19/2024 10:17:08'!
restore

	| saved |
	saved := self unsave.
	input position: saved key.
	lookahead := saved value! !

!BaseParser methodsFor: 'backtracking' stamp: 'ess 11/27/2024 10:53:02'!
save

	shift addLast: input position -> lookahead.
	^input position! !

!BaseParser methodsFor: 'backtracking' stamp: 'ess 11/27/2024 10:54:07'!
unsave

	shift isEmpty ifTrue: [^self error: 'BaseParser internal error: restore without save'].
	^shift removeLast! !

!BaseParser methodsFor: 'backtracking' stamp: 'ess 11/27/2024 10:54:42'!
withSaveDo: aUnaryBlock

	| didRestore restore |
	didRestore := false.
	restore :=
		[self restore.
		didRestore := true].
	self save.
	^[aUnaryBlock value: restore] ensure:
		[didRestore ifFalse: [self unsave]]! !

!BaseParser methodsFor: 'initialization' stamp: 'ess 11/1/2024 19:26:09'!
initialize

	shift := OrderedCollection new! !

!BaseParser methodsFor: 'initialization' stamp: 'ess 11/7/2024 15:27:22'!
parseError: aMessageString

	^ ParseError signal: aMessageString! !

!BaseParser methodsFor: 'parsing' stamp: 'ess 11/18/2024 03:42:10'!
consume
	"Update lookahead to the next character of the input, or nil.  Answer the old value of the lookahead."

	| la |
	la := lookahead ifNil: [ ^ self parseError: 'Unexpected end of input' ].
	self step.
	^ la! !

!BaseParser methodsFor: 'parsing' stamp: 'ess 11/28/2024 09:36:22'!
expect: aCharacter

	(self match: aCharacter) ifFalse:
		[^self parseError: 'Expected ', aCharacter asString]! !

!BaseParser methodsFor: 'parsing' stamp: 'ess 11/14/2024 09:09:30'!
lookahead

	^ lookahead! !

!BaseParser methodsFor: 'parsing' stamp: 'ess 11/28/2024 09:57:26'!
match: aCharacter
	"Consume the next character only if it matches aCharacter.  Answer true if the match succeeded."

	| isMatch |
	isMatch := lookahead == aCharacter.
	isMatch ifTrue: [self consume].
	^isMatch! !

!BaseParser methodsFor: 'parsing' stamp: 'ess 11/26/2024 15:43:36'!
next

	^input next! !

!BaseParser methodsFor: 'parsing' stamp: 'ess 11/2/2024 03:23:33'!
parse

	^ self subclassResponsibility! !

!BaseParser methodsFor: 'parsing' stamp: 'ess 11/26/2024 07:41:44'!
parse: aStringOrStream

	self input: aStringOrStream.
	^self parse! !

!BaseParser methodsFor: 'parsing' stamp: 'ess 11/27/2024 10:53:55'!
step
	"Move to next character of input."

	lookahead := input atEnd
		ifFalse: [self next]
		ifTrue: [nil]! !

!BaseParser methodsFor: 'testing' stamp: 'ess 11/2/2024 05:15:43'!
atEnd

	^ lookahead isNil! !

!BaseParser methodsFor: 'testing' stamp: 'ess 11/3/2024 09:04:24'!
didSucceed
	"We succeeded if we parsed all the input."

	^ self atEnd! !

!BaseParser methodsFor: 'testing' stamp: 'ess 11/17/2024 19:16:01'!
isAscii

	^ lookahead notNil
		and: [ lookahead codePoint <= 127 ]! !

!BaseParser methodsFor: 'testing' stamp: 'ess 1/7/2025 14:12:18'!
isDigit

	^ lookahead notNil
		and: [ lookahead isDigit ]! !

!BaseParser methodsFor: 'private' stamp: 'ess 11/18/2024 03:42:20'!
consumeDigit

	self isDigit ifFalse: [ ^ self parseError: 'Expected decimal digit' ].
	^ self consume xDigitValue! !

!BaseParser class methodsFor: 'parsing' stamp: 'ess 11/26/2024 07:41:34'!
parse: aStringOrStream

	^self new parse: aStringOrStream! !

!PercentEncoding methodsFor: 'parsing' stamp: 'ess 11/2/2024 05:16:40'!
parse

	^ String streamContents:
		[ :out | | chars |
		[ self atEnd ] whileFalse:
			[ (lookahead = $%
					and: [ (chars := self readEncodedCharacters) notNil ])
				ifTrue: [ out nextPutAll: chars ]
				ifFalse: [ out nextPut: self consume ] ] ]! !

!PercentEncoding methodsFor: 'private' stamp: 'ess 11/3/2024 08:57:19'!
readEncodedByte

	| a b |

	(self match: $%)
		ifFalse: [ ^ nil ].

	a := self readHexDigit.
	b := self readHexDigit.
	^ a notNil & (b notNil)
		ifTrue: [ a * 16 + b ]
		ifFalse: [ nil ]! !

!PercentEncoding methodsFor: 'private' stamp: 'ess 11/2/2024 03:08:20'!
readEncodedBytes

	| bytes |

	bytes := ByteArray streamContents:
				[ :out | | byte |
				[ lookahead = $%
						and: [ (byte := self readEncodedByte) notNil ] ]
					whileTrue:
						[ out nextPut: byte ] ].
					
	^ bytes notEmpty
		ifTrue: [ bytes ]
		ifFalse: [ nil ]! !

!PercentEncoding methodsFor: 'private' stamp: 'ess 1/7/2025 14:17:49'!
readEncodedCharacters

	^ self withSaveDo:
		[ :reset |
		[ self readEncodedBytes
				ifNotNil: [ :octets | CharacterSequence fromUtf8Bytes: octets ] ]
			on: Error
			do: [ reset value.
				^ nil ] ]! !

!PercentEncoding methodsFor: 'private' stamp: 'ess 11/2/2024 05:05:18'!
readHexDigit

	| d |

	d := lookahead
			ifNotNil: [ self consume asUppercase digitValue ].
	^ (d notNil and: [ d between: 0 and: 15 ])
		ifTrue: [ d ]
		ifFalse: [ nil ]! !

!PercentEncoding class methodsFor: 'constants' stamp: 'ess 11/2/2024 09:56:57'!
unreservedCodepoints

	^ `
		'-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~'
			inject: (Array new: 127 withAll: false)
			into:
				[ :lookup :index |
				lookup
					at:index codePoint
					put: true.
				lookup ]
	`! !

!PercentEncoding class methodsFor: 'converting' stamp: 'ess 11/3/2024 09:07:18'!
decode: aStringOrStream

	^ self parse: aStringOrStream! !

!PercentEncoding class methodsFor: 'converting' stamp: 'ess 11/3/2024 08:44:36'!
encode: aStringOrBytes

	| hexDigits bytes |

	hexDigits := `
		'0123456789ABCDEF' asByteArray
	`.

	bytes := aStringOrBytes isString
				ifTrue: [ aStringOrBytes asUtf8Bytes ]
				ifFalse: [ aStringOrBytes ].
	^ (ByteArray streamContents:
		[ :out |
		bytes do:
			[ :each |
			(self isUnreservedCodepoint: each)
				ifTrue: [ out nextPut: each ]
				ifFalse:
					[ out
						nextPut: `$% codePoint`;
						nextPut: (hexDigits at: each // 16 + 1);
						nextPut: (hexDigits at: each \\ 16 + 1) ] ] ])
			asString! !

!PercentEncoding class methodsFor: 'converting' stamp: 'ess 11/3/2024 07:50:28'!
normalize: anEncodedString

	^ self encode: (self decode: anEncodedString)! !

!PercentEncoding class methodsFor: 'testing' stamp: 'ess 11/3/2024 08:45:18'!
isUnreserved: aCharacter
	"Characters that are allowed in a URI but do not have a reserved purpose are called unreserved.  These include uppercase and lowercase letters, decimal digits, hyphen, period, underscore, and tilde.
	
	Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-2.3"
	
	^ self isUnreservedCodepoint: aCharacter codePoint! !

!PercentEncoding class methodsFor: 'testing' stamp: 'ess 11/2/2024 09:54:54'!
isUnreservedCodepoint: aCodePoint

	^ (aCodePoint
		between: `$- codePoint`
		and: `$~ codePoint`)
			and: [ self unreservedCodepoints at: aCodePoint ]! !

!URIParser methodsFor: 'constants' stamp: 'ess 11/1/2024 05:43:11'!
subDelimiters

	^ '!!$&''()*+,;='! !

!URIParser methodsFor: 'parsing' stamp: 'ess 11/3/2024 09:04:24'!
parse

	uri scheme: self readScheme.
	self parseHierarchicalPart.
	(self match: $?)
		ifTrue: [ uri query: self readQuery ].
	(self match: $#)
		ifTrue: [ uri fragment: self readFragment ].
		
	^ self didSucceed
		ifTrue: [ uri ]
		ifFalse: [ nil ]! !

!URIParser methodsFor: 'parsing' stamp: 'ess 11/3/2024 09:12:30'!
parse: aString into: aUri

	uri := aUri.
	^ self parse: aString! !

!URIParser methodsFor: 'testing' stamp: 'ess 11/2/2024 08:29:51'!
isAlphaNumeric

	^ self isAscii
		and: [ lookahead isAlphaNumeric ]! !

!URIParser methodsFor: 'testing' stamp: 'ess 11/2/2024 04:07:05'!
isHostnameCharacter

	^(self isUnreserved
		or: [ self isSubDelimiter ])
		or: [ self isPercentEncoding ]! !

!URIParser methodsFor: 'testing' stamp: 'ess 11/2/2024 12:08:10'!
isLetter

	^ self isAscii
		and: [ lookahead isLetter ]! !

!URIParser methodsFor: 'testing' stamp: 'ess 11/1/2024 13:25:54'!
isNocolonPathCharacter

	^ (lookahead ~= $:) & self isPathCharacter! !

!URIParser methodsFor: 'testing' stamp: 'ess 11/2/2024 04:07:05'!
isPathCharacter

	^ (self isUnreserved
		or: [ self isSubDelimiterOr: ':@' ])
		or: [ self isPercentEncoding ]! !

!URIParser methodsFor: 'testing' stamp: 'ess 1/7/2025 14:17:54'!
isPercentEncoding
	"Answer true if lookahead is the start of a valid percent-encoded sequence."

	^ lookahead = $%
		and: [ self withSaveDo:
				[ :reset | | a b |
				self consume.
				a := lookahead ifNotNil: [ self consume asUppercase digitValue ].
				b := lookahead ifNotNil: [ self consume asUppercase digitValue ].
				reset value.
				(a notNil and: [ a between: 0 and: 15 ])
					and: [ b notNil and: [ b between: 0 and: 15 ] ] ] ]! !

!URIParser methodsFor: 'testing' stamp: 'ess 11/1/2024 07:13:18'!
isQueryCharacter

	^ self isPathCharacter
		or: [ '/?' includes: lookahead ]! !

!URIParser methodsFor: 'testing' stamp: 'ess 11/2/2024 12:07:50'!
isSchemeCharacter

	^ self isAlphaNumeric
		or: [ '+-.' includes: lookahead ]! !

!URIParser methodsFor: 'testing' stamp: 'ess 11/1/2024 13:09:25'!
isSchemeStartCharacter

	^ self isLetter! !

!URIParser methodsFor: 'testing' stamp: 'ess 11/2/2024 03:21:59'!
isSubDelimiter

	^ self subDelimiters
		includes: lookahead! !

!URIParser methodsFor: 'testing' stamp: 'ess 11/2/2024 03:20:48'!
isSubDelimiterOr: otherAllowedCharacters

	^ (self subDelimiters, otherAllowedCharacters)
		includes: lookahead! !

!URIParser methodsFor: 'testing' stamp: 'ess 11/2/2024 09:04:47'!
isUnreserved

	^ lookahead notNil
		and: [ PercentEncoding isUnreserved: lookahead ]! !

!URIParser methodsFor: 'testing' stamp: 'ess 11/2/2024 04:07:05'!
isUserinfoCharacter

	^ ((lookahead = $:
		or: [ self isUnreserved ])
		or: [ self isSubDelimiter ])
		or: [ self isPercentEncoding ]! !

!URIParser methodsFor: 'private-authority' stamp: 'ess 11/2/2024 03:26:59'!
parseAuthority

	uri userinfo: self readUserinfo.
	uri host: self readHost.
	((self match: $:) and: [ self isDigit ])
		ifTrue: [ uri port: self readPort ]! !

!URIParser methodsFor: 'private-authority' stamp: 'ess 11/3/2024 09:31:53'!
parseHierarchicalPart

	uri path:
		((self match: $/)
			ifTrue:
				[ (self match: $/)
					ifFalse: [ self readAbsolutePath ]
					ifTrue:
						[ self parseAuthority.
						(self match: $/)
							ifTrue: [ self readAbsolutePath ]
							ifFalse: [ nil ] ] ]
			ifFalse:
				[self isPathCharacter
					ifFalse: [ nil ]
					ifTrue:
						[ uri scheme
						ifNotNil: [ self readRelativePath ]
						ifNil: [ self readNoschemePath ] ] ])! !

!URIParser methodsFor: 'private-authority' stamp: 'ess 11/1/2024 13:00:30'!
readHost

	lookahead = $[
		ifTrue: [ ^ self readIpLiteral ].

	^ self isDigit
		ifFalse: [ self readHostname ]
		ifTrue:
			[ self readIPv4
				ifNil: [ self readHostname ] ]! !

!URIParser methodsFor: 'private-authority' stamp: 'ess 11/2/2024 04:16:56'!
readHostname

	^ self readPercentEncodingSatisfying: [ :la | self isHostnameCharacter ]! !

!URIParser methodsFor: 'private-authority' stamp: 'ess 1/7/2025 14:17:59'!
readIPv4

	^ self withSaveDo:
			[ :reset |
			(1 to: 4) collect:
				[ :i |
				i > 1 ifTrue:
					[ (self match: $.)
						ifFalse:
							[ reset value.
							^ nil ] ].
				self readOctet
					ifNil:
						[ reset value.
						^ nil ] ] ]! !

!URIParser methodsFor: 'private-authority' stamp: 'ess 11/1/2024 12:50:13'!
readIpLiteral

	"Not yet implemented."
	^ nil! !

!URIParser methodsFor: 'private-authority' stamp: 'ess 11/2/2024 04:14:09'!
readOctet

	| octet |

	self isDigit ifFalse: [ nil ].

	octet := self consume digitValue.
	self isDigit ifTrue: [ octet := octet * 10 + self consume digitValue ].
	self isDigit ifTrue: [ octet := octet * 10 + self consume digitValue ].

	(octet between: 0 and: 255)
		ifFalse: [ ^ nil ].
	^ octet! !

!URIParser methodsFor: 'private-authority' stamp: 'ess 11/1/2024 13:03:33'!
readPort

	| port |

	port := 0.
	[ self isDigit ]
		whileTrue:
			[ port := port * 10 + self consume digitValue ].
	^ port! !

!URIParser methodsFor: 'private-miscellaneous' stamp: 'ess 11/1/2024 10:29:14'!
readFragment

	"Fragments accept the same characters as queries."
	^ self readQuery! !

!URIParser methodsFor: 'private-miscellaneous' stamp: 'ess 11/2/2024 04:11:21'!
readPercentEncodingSatisfying: aBlock

	^ String streamContents:
		[ :stream |
		[ aBlock value: lookahead ]
			whileTrue:
				[ (lookahead = $% and: [ self isPercentEncoding ])
					ifFalse: [ stream nextPut: self consume ]
					ifTrue:
						[ 3 timesRepeat: [ stream nextPut: self consume ] ] ] ]! !

!URIParser methodsFor: 'private-miscellaneous' stamp: 'ess 11/2/2024 04:11:21'!
readQuery

	^ self readPercentEncodingSatisfying: [ :la | self isQueryCharacter ]! !

!URIParser methodsFor: 'private-miscellaneous' stamp: 'ess 1/7/2025 14:18:04'!
readScheme

	self isSchemeStartCharacter ifFalse: [ ^ nil ].
	
	^ self withSaveDo:
		[ :reset | | scheme |
		scheme := String streamContents:
			[ :out |
			[ self isSchemeCharacter ]
				whileTrue: [ out nextPut: self consume ] ].
		(self match: $:)
			ifTrue: [ scheme ]
			ifFalse: [ reset value.
					nil ] ]! !

!URIParser methodsFor: 'private-path' stamp: 'ess 11/3/2024 07:54:25'!
readAbsolutePath

	| firstSegment |

	firstSegment := self readPathSegment.
	firstSegment isEmpty
		ifTrue: [ ^ URIPath root ].
		
	^ URIPath
		absolute: (self readPathSegmentsAfter: firstSegment)! !

!URIParser methodsFor: 'private-path' stamp: 'ess 11/2/2024 04:18:17'!
readNocolonPathSegment

	| segment |

	segment := self readPercentEncodingSatisfying: [ :la | self isNocolonPathCharacter ].
	segment isEmpty
		ifTrue: [ URIParseError signal: 'Expected non-empty path segment' ].		
	^ segment! !

!URIParser methodsFor: 'private-path' stamp: 'ess 11/1/2024 06:30:32'!
readNonemptyPathSegment

	self isPathCharacter
		ifFalse: [ URIParseError signal: 'Expected non-empty path segment' ].
		
	^ self readPathSegment! !

!URIParser methodsFor: 'private-path' stamp: 'ess 11/1/2024 07:10:40'!
readNoschemePath

	^ self readRelativePathAfter: self readNocolonPathSegment! !

!URIParser methodsFor: 'private-path' stamp: 'ess 11/2/2024 04:18:33'!
readPathSegment
	"May be empty."
	
	^ self readPercentEncodingSatisfying: [ :la | self isPathCharacter ]! !

!URIParser methodsFor: 'private-path' stamp: 'ess 11/1/2024 10:57:08'!
readPathSegments

	| segments |

	segments := OrderedCollection with: self readPathSegment.
	[ self match: $/ ]
		whileTrue:
			[ segments add: self readPathSegment ].

	^ segments! !

!URIParser methodsFor: 'private-path' stamp: 'ess 11/1/2024 10:57:33'!
readPathSegmentsAfter: firstSegment

	| segments |
	
	segments := OrderedCollection with: firstSegment.
	(self match: $/)
		ifTrue:
			[ segments addAll: self readPathSegments ].
		
	^ segments! !

!URIParser methodsFor: 'private-path' stamp: 'ess 11/1/2024 07:10:40'!
readRelativePath

	^ self readRelativePathAfter: self readNonemptyPathSegment! !

!URIParser methodsFor: 'private-path' stamp: 'ess 11/1/2024 09:22:41'!
readRelativePathAfter: firstSegment

	^ URIPath
		relative: (self readPathSegmentsAfter: firstSegment)! !

!URIParser methodsFor: 'private-path' stamp: 'ess 1/7/2025 14:18:10'!
readUserinfo

	^ self withSaveDo:
		[ :reset | | userinfo |
		userinfo := self readPercentEncodingSatisfying: [ :la | self isUserinfoCharacter ].
		(self match: $@)
			ifTrue: [ userinfo ]
			ifFalse: [ reset value.
					nil ] ]! !

!URIParser class methodsFor: 'parsing' stamp: 'ess 11/3/2024 09:12:53'!
parse: aString into: aUri

	^ self new
		parse: aString
		into: aUri! !

!URI methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:31:38'!
authority

	^ authority! !

!URI methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:31:52'!
authority: anObjectOrNil

	authority := anObjectOrNil! !

!URI methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:31:57'!
fragment

	^ fragment! !

!URI methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:32:09'!
fragment: aStringOrNil

	fragment := aStringOrNil! !

!URI methodsFor: 'accessing' stamp: 'ess 11/1/2024 11:52:53'!
host

	^ authority ifNotNil: [ authority host ]! !

!URI methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:32:55'!
host: anObjectOrNil

	authority
		ifNil: [ authority := URIAuthority new ].
	authority host: anObjectOrNil! !

!URI methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:35:20'!
password

	^ authority ifNotNil: [ authority password ]! !

!URI methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:33:38'!
path

	^ path! !

!URI methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:33:57'!
path: aPathObjectOrNil

	path := aPathObjectOrNil! !

!URI methodsFor: 'accessing' stamp: 'ess 11/1/2024 14:38:06'!
port

	^ authority ifNotNil: [ authority port ]! !

!URI methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:33:30'!
port: aPortNumberOrNil

	authority
		ifNil: [ authority := URIAuthority new ].
	authority port: aPortNumberOrNil! !

!URI methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:34:03'!
query

	^ query! !

!URI methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:34:14'!
query: aStringOrNil

	query := aStringOrNil! !

!URI methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:34:20'!
scheme

	^ scheme! !

!URI methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:34:31'!
scheme: aStringOrNil

	scheme := aStringOrNil! !

!URI methodsFor: 'accessing' stamp: 'ess 11/1/2024 11:53:08'!
userinfo

	^ authority ifNotNil: [ authority userinfo ]! !

!URI methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:34:52'!
userinfo: aStringOrNil

	authority
		ifNil: [ authority := URIAuthority new ].
	authority userinfo: aStringOrNil! !

!URI methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:35:14'!
username

	^ authority ifNotNil: [ authority username ]! !

!URI methodsFor: 'comparing' stamp: 'ess 11/3/2024 10:18:25'!
= aUri

	self == aUri ifTrue: [ ^ true ].
	^ (((((aUri is: #URI)
			and: [ scheme == aUri scheme ])
			and: [ authority == aUri authority ])
			and: [ path == aUri path ])
			and: [ query == aUri query ])
			and: [ fragment == aUri fragment ]! !

!URI methodsFor: 'comparing' stamp: 'ess 11/3/2024 10:16:01'!
hash

	^ { scheme. authority. path. query. fragment }
		inject: self class hash
		into: [ :hash :component | hash bitXor: component hash ]! !

!URI methodsFor: 'converting' stamp: 'ess 11/3/2024 09:15:56'!
asNormal

	^ self copy
		beNormal;
		yourself! !

!URI methodsFor: 'converting' stamp: 'ess 11/3/2024 09:15:40'!
beNormal

	scheme := scheme ifNotNil: [ scheme asLowercase ].
	authority := authority ifNotNil: [ authority asNormal ].
	path := path ifNotNil: [ path asNormal ].
	query := query ifNotNil: [ PercentEncoding normalize: query ].
	fragment := fragment ifNotNil: [ PercentEncoding normalize: fragment ]! !

!URI methodsFor: 'converting' stamp: 'ess 11/4/2024 05:52:34'!
relativeTo: aBaseUri
	"Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-5.2"

	| target |
	
	target := self species new.
	target fragment: fragment.

	scheme ifNotNil:
		[ target
			scheme: scheme;
			authority: authority;
			path: (path ifNotNil: [ path withoutDotSegments ]);
			query: query.
		^ target ].
	target scheme: aBaseUri scheme.
	
	authority ifNotNil:
		[ target
			authority: authority;
			path: (path ifNotNil: [ path withoutDotSegments ]);
			query: query.
		^ target ].	
	target authority: aBaseUri authority.
	
	path ifNil:
		[ target
			path: aBaseUri path;
			query: (query ifNil: [ aBaseUri query ]).
		^ target ].
	target query: query.
	
	target path:
		(path isAbsolute
			ifTrue: [ path withoutDotSegments ]
			ifFalse: [ path relativeTo: aBaseUri path ]).
	^ target
! !

!URI methodsFor: 'printing' stamp: 'ess 11/4/2024 05:53:22'!
printOn: aStream
	"Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-5.3"

	scheme ifNotNil:
		[ aStream
			nextPutAll: scheme;
			nextPut: $: ].
	authority ifNotNil:
		[ aStream
			nextPutAll: '//';
			nextPutAll: authority asString ].
	path ifNotNil:
		[ aStream nextPutAll: path asString ].
	query ifNotNil:
		[ aStream
			nextPut: $?;
			nextPutAll: query ].
	fragment ifNotNil:
		[ aStream
			nextPut: $#;
			nextPutAll: fragment ]! !

!URI methodsFor: 'testing' stamp: 'ess 11/3/2024 10:19:05'!
is: aSymbol

	^ aSymbol == #URI or: [ super is: aSymbol ]! !

!URI class methodsFor: 'instance creation' stamp: 'ess 11/3/2024 09:13:02'!
fromString: aString

	^ URIParser
		parse: aString
		into: self new! !

!URIAuthority methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:30:13'!
host

	^ host! !

!URIAuthority methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:30:57'!
host: anObjectOrNil

	host := anObjectOrNil! !

!URIAuthority methodsFor: 'accessing' stamp: 'ess 11/2/2024 10:37:28'!
password

	^ userinfo ifNotNil:
		[ | separator |
		separator := userinfo indexOf: $:.
		separator isZero
			ifTrue: [ nil ]
			ifFalse:
				[ userinfo
					copyFrom: separator + 1
					to: userinfo size ] ]! !

!URIAuthority methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:30:24'!
port

	^ port! !

!URIAuthority methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:30:44'!
port: aPortNumberOrNil

	port := aPortNumberOrNil! !

!URIAuthority methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:31:09'!
userinfo

	^ userinfo! !

!URIAuthority methodsFor: 'accessing' stamp: 'ess 11/1/2024 13:31:21'!
userinfo: aStringOrNil

	userinfo := aStringOrNil! !

!URIAuthority methodsFor: 'accessing' stamp: 'ess 11/2/2024 10:37:00'!
username

	^ userinfo ifNotNil:
		[ | separator |
		separator := userinfo indexOf: $:.
		separator isZero
			ifTrue: [ nil ]
			ifFalse:
				[ userinfo
					copyFrom: 1
					to: separator - 1 ] ]! !

!URIAuthority methodsFor: 'comparing' stamp: 'ess 11/3/2024 10:14:45'!
= aUriAuthority

	self == aUriAuthority ifTrue: [ ^ true ].
	^ ((userinfo == aUriAuthority userinfo)
		and: [ host == aUriAuthority host ])
		and: [ port == aUriAuthority port ]! !

!URIAuthority methodsFor: 'comparing' stamp: 'ess 11/3/2024 10:13:29'!
hash

	^ ((self class hash
		bitXor: userinfo hash)
		bitXor: host hash)
		bitXor: port hash! !

!URIAuthority methodsFor: 'converting' stamp: 'ess 11/3/2024 09:11:23'!
asNormal

	^ self copy
		beNormal;
		yourself! !

!URIAuthority methodsFor: 'converting' stamp: 'ess 11/3/2024 09:11:10'!
beNormal

	userinfo := userinfo ifNotNil: [ PercentEncoding normalize: userinfo ].
	(host notNil and: [ host isString ])
		ifTrue: [ host := host asLowercase ]! !

!URIAuthority methodsFor: 'printing' stamp: 'ess 11/2/2024 16:05:02'!
printOn: aStream

	userinfo ifNotNil:
		[ aStream
			nextPutAll: userinfo;
			nextPut: $@ ].
	host ifNotNil:
		[ aStream nextPutAll: host ].
	port ifNotNil:
		[ aStream
			nextPut: $:;
			print: port ]! !

!URIAuthority methodsFor: 'testing' stamp: 'ess 11/3/2024 10:18:48'!
is: aSymbol

	^ aSymbol == #URIAuthority or: [ super is: aSymbol ]! !

!URIPath methodsFor: 'accessing' stamp: 'ess 11/3/2024 07:53:46'!
segments
	"Can be nil for an empty path."

	^ segments! !

!URIPath methodsFor: 'comparing' stamp: 'ess 11/3/2024 10:12:02'!
= aPath

	self == aPath ifTrue: [ ^ true ].
	^ ((aPath is: #URIPath)
		and: [ isAbsolute == aPath isAbsolute ])
		and: [ segments == aPath segments ]! !

!URIPath methodsFor: 'comparing' stamp: 'ess 11/3/2024 10:11:37'!
hash

	^ (self class hash
		bitXor: isAbsolute hash)
		bitXor: segments hash! !

!URIPath methodsFor: 'converting' stamp: 'ess 11/3/2024 07:51:07'!
asNormal

	^ self copy
		beNormal;
		yourself! !

!URIPath methodsFor: 'converting' stamp: 'ess 11/3/2024 07:52:38'!
beNormal
	"Normalize internal representation.

	Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.3"

	segments := segments ifNotNil:
					[ segments collect:
						[ :each | PercentEncoding normalize: each ] ].
					
	self removeDotSegments! !

!URIPath methodsFor: 'converting' stamp: 'ess 11/3/2024 08:37:18'!
relativeTo: aBasePath
	"Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-5.2"

	(aBasePath isNil or: [ aBasePath segments isNil ])
		ifTrue: [ ^ self withoutDotSegments ].

	^ (self species new
		setSegments: aBasePath segments allButLast, segments
		isAbsolute: aBasePath isAbsolute)
			withoutDotSegments! !

!URIPath methodsFor: 'converting' stamp: 'ess 11/3/2024 07:52:46'!
removeDotSegments
	"Reference: https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4"

	| result isDirectory |

	segments
		ifNil: [ ^ self ].

	"Track if the last component added to result should be interpreted as a directory reference."
	isDirectory := false.

	result := OrderedCollection new.
	segments do:
		[ :each |
		(each = '..' and: [ result notEmpty ])
			ifTrue: [ result removeLast ].
		isDirectory := each = '..' | (each = '.').
		isDirectory
			ifFalse: [ result addLast: each ] ].

	"Add an empty path segment to show that result is a directory."
	isDirectory
		ifTrue: [ result addLast: '' ].
		
	segments := result! !

!URIPath methodsFor: 'converting' stamp: 'ess 11/3/2024 07:53:07'!
withoutDotSegments

	^ self copy
		removeDotSegments;
		yourself! !

!URIPath methodsFor: 'printing' stamp: 'ess 11/2/2024 16:03:27'!
printOn: aStream

	isAbsolute
		ifTrue: [ aStream nextPut: $/ ].
	segments
		do: [ :each | aStream nextPutAll: each ]
		separatedBy: [ aStream nextPut: $/ ]! !

!URIPath methodsFor: 'testing' stamp: 'ess 11/3/2024 10:07:46'!
is: aSymbol

	^ aSymbol == #URIPath or: [ super is: aSymbol ]! !

!URIPath methodsFor: 'testing' stamp: 'ess 11/3/2024 07:41:52'!
isAbsolute

	^ isAbsolute! !

!URIPath methodsFor: 'testing' stamp: 'ess 11/3/2024 08:32:53'!
isDirectory
	"Am I a directory reference?"

	"We represent directories with a final empty segment."
	^ segments isEmptyOrNil not
		and: [ segments last isEmpty ]! !

!URIPath methodsFor: 'testing' stamp: 'ess 11/3/2024 08:32:26'!
isEmpty
	"Do I represent an empty path?"

	"Segments notNil and isEmpty denotes the root path '/' "
	^ segments isNil! !

!URIPath methodsFor: 'testing' stamp: 'ess 11/1/2024 13:36:34'!
isRelative

	^ isAbsolute not! !

!URIPath methodsFor: 'testing' stamp: 'ess 11/3/2024 07:36:04'!
notEmpty

	^ segments notNil! !

!URIPath methodsFor: 'private' stamp: 'ess 11/3/2024 07:43:34'!
setSegments: pathSegments isAbsolute: aBoolean

	segments := pathSegments.
	isAbsolute := aBoolean.
	^ self! !

!URIPath class methodsFor: 'instance creation' stamp: 'ess 11/3/2024 07:56:12'!
absolute: pathSegments

	^ self new
		setSegments: pathSegments
		isAbsolute: true! !

!URIPath class methodsFor: 'instance creation' stamp: 'ess 11/3/2024 07:56:26'!
empty

	^ self new
		setSegments: nil
		isAbsolute: false! !

!URIPath class methodsFor: 'instance creation' stamp: 'ess 11/3/2024 07:55:08'!
relative: pathSegments

	^ self new
		setSegments: pathSegments
		isAbsolute: false! !

!URIPath class methodsFor: 'instance creation' stamp: 'ess 11/3/2024 07:55:46'!
root

	^ self new
		setSegments: OrderedCollection new
		isAbsolute: true! !

!ByteArray methodsFor: '*URI-converting' stamp: 'ess 11/3/2024 08:49:47'!
percentEncoded

	^ PercentEncoding encode: self! !

!CharacterSequence methodsFor: '*URI-converting' stamp: 'ess 11/3/2024 08:48:56'!
percentDecoded

	^ PercentEncoding decode: self! !

!CharacterSequence methodsFor: '*URI-converting' stamp: 'ess 11/3/2024 08:48:31'!
percentEncoded

	^ PercentEncoding encode: self! !
